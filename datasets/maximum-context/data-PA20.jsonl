{"task_id": "PA20/Archer.java", "target": "assignment/piece/Archer.java", "code": "```java\npackage assignment.piece;\n\nimport assignment.piece.ArcherMoveRule;\nimport assignment.piece.FirstNMovesProtectionRule;\nimport assignment.piece.NilMoveRule;\nimport assignment.piece.OccupiedRule;\nimport assignment.piece.OutOfBoundaryRule;\nimport assignment.piece.Rule;\nimport assignment.piece.VacantRule;\nimport assignment.protocol.Configuration;\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\nimport assignment.protocol.Piece;\nimport assignment.protocol.Place;\nimport assignment.protocol.Player;\n\nimport java.util.*;\nimport java.util.function.IntFunction;\nimport java.util.function.Predicate;\nimport java.util.stream.Stream;\n\n/**\n * Archer piece that moves similar to cannon in chinese chess.\n * Rules of move of Archer can be found in wikipedia (https://en.wikipedia.org/wiki/Xiangqi#Cannon).\n * <p>\n * <strong>Attention: If you want to implement Archer as the bonus task, you should remove \"{@code throw new\n * UnsupportedOperationException();}\" in the constructor of this class.</strong>\n *\n * @see <a href='https://en.wikipedia.org/wiki/Xiangqi#Cannon'>Wikipedia</a>\n */\npublic class Archer extends Piece {\n    public Archer(Player player) {\n        super(player);\n        throw new UnsupportedOperationException(); // remove this line if you plan to implement Archer\n    }\n\n    @Override\n    public char getLabel() {\n        return 'A';\n    }\n\n    /**\n     * Returns an array of moves that are valid given the current place of the piece.\n     * Given the {@link Game} object and the {@link Place} that current knight piece locates, this method should\n     * return ALL VALID {@link Move}s according to the current {@link Place} of this knight piece.\n     * All the returned {@link Move} should have source equal to the source parameter.\n     * <p>\n     * Hint: you should consider corner cases when the {@link Move} is not valid on the gameboard.\n     * Several tests are provided and your implementation should pass them.\n     * <p>\n     * <strong>Attention: Student should make sure all {@link Move}s returned are valid.</strong>\n     *\n     * @param game   the game object\n     * @param source the current place of the piece\n     * @return an array of available moves\n     */\n    @Override\n    public Move[] getAvailableMoves(Game game, Place source) {\n        // TODO student implementation\n        return new Move[0];\n    }\n}\n\n```\n", "code_context": "```java\npackage assignment.piece;\n\nimport assignment.piece.Archer;\nimport assignment.piece.Rule;\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\nimport assignment.protocol.Piece;\nimport assignment.protocol.Place;\nimport assignment.protocol.Player;\n\n/**\n * The rule of moving of Archer, which is similar to the moving rule of cannon in Chinese chess.\n * Cannons move like chariots, any distance orthogonally without jumping, but can only capture by jumping a single piece of either colour along the path of attack.\n */\npublic class ArcherMoveRule implements Rule {\n    @Override\n    public boolean validate(Game game, Move move) {\n        if (!(game.getPiece(move.getSource()) instanceof Archer)) {\n            return true;\n        }\n        // TODO student implementation\n        return false;\n    }\n\n    @Override\n    public String getDescription() {\n        return \"archer move rule is violated\";\n    }\n}\n\n```\n\n```java\npackage assignment.piece;\n\nimport assignment.piece.Rule;\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\nimport assignment.protocol.Piece;\nimport assignment.protocol.Place;\n\n/**\n * The rule that requires capturing piece is not allowed within the first certain number of moves.\n */\npublic class FirstNMovesProtectionRule implements Rule {\n    /**\n     * The number of moves within which capturing piece is not allowed.\n     */\n    private final int numProtectedMoves;\n\n    public FirstNMovesProtectionRule(int numProtectedMoves) {\n        this.numProtectedMoves = numProtectedMoves;\n    }\n\n    @Override\n    public boolean validate(Game game, Move move) {\n        // TODO\n        return false;\n    }\n\n    @Override\n    public String getDescription() {\n        return \"Capturing piece in the first \" + this.numProtectedMoves + \" moves are not allowed\";\n    }\n}\n\n```\n\n```java\npackage assignment.piece;\n\nimport assignment.piece.Rule;\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\nimport assignment.protocol.Place;\n\n/**\n * Global rule that requires the source and destination of a move should not be the same.\n */\npublic class NilMoveRule implements Rule {\n    @Override\n    public boolean validate(Game game, Move move) {\n        // TODO\n        return false;\n    }\n\n    @Override\n    public String getDescription() {\n        return \"the source and destination of move should be different places\";\n    }\n}\n\n```\n\n```java\npackage assignment.piece;\n\nimport assignment.piece.Rule;\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\nimport assignment.protocol.Piece;\nimport assignment.protocol.Place;\nimport assignment.protocol.Player;\n\n/**\n * Global rule that requires that a piece should not go to a destination where there is another piece belonging to the\n * same player.\n */\npublic class OccupiedRule implements Rule {\n    @Override\n    public boolean validate(Game game, Move move) {\n        // TODO\n        return false;\n    }\n\n    @Override\n    public String getDescription() {\n        return \"piece cannot be captured by another piece belonging to the same player\";\n    }\n}\n\n```\n\n```java\npackage assignment.piece;\n\nimport assignment.piece.Rule;\nimport assignment.protocol.Configuration;\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\nimport assignment.protocol.Place;\n\n/**\n * Global rule that requires the source and destination should be inside the board boundary.\n */\npublic class OutOfBoundaryRule implements Rule {\n    @Override\n    public boolean validate(Game game, Move move) {\n        // TODO\n        return false;\n    }\n\n    @Override\n    public String getDescription() {\n        return \"place is out of boundary of gameboard\";\n    }\n}\n\n```\n\n```java\npackage assignment.piece;\n\n\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\n\n/**\n * Interface that a rule should implement.\n * Every mode in the gameboard should not violate the rule.\n */\npublic interface Rule {\n    /**\n     * Validate the move. if the rule is violated return false.\n     * <p>\n     * [Hint] the piece that is to be moved can be obtained using {@code game.getPiece(move.getSource()}.\n     *\n     * @param game the current game object\n     * @param move the move to be validated\n     * @return true if the rule check pass. If the rule is violated, return false.\n     */\n    public boolean validate(Game game, Move move);\n\n    /**\n     * Returns a string description of the rule, which will be printed as error message when the rule is violated.\n     *\n     * @return description of the rule\n     */\n    public String getDescription();\n}\n\n// Below are several predefined global rules for all moves.\n\n\n```\n\n```java\npackage assignment.piece;\n\nimport assignment.piece.Rule;\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\nimport assignment.protocol.Piece;\nimport assignment.protocol.Place;\n\n/**\n * Global rule that requires the source place of a move must have a piece on it.\n */\npublic class VacantRule implements Rule {\n    @Override\n    public boolean validate(Game game, Move move) {\n        // TODO student implementation\n        return false;\n    }\n\n    @Override\n    public String getDescription() {\n        return \"the source of move should have a piece\";\n    }\n}\n\n```\n\n```java\npackage assignment.protocol;\n\nimport assignment.protocol.exception.InvalidConfigurationError;\n\n/**\n * Game configuration, including:\n * 1. size of gameboard\n * 2. place (square) of central square in classical Jeson Mor\n * 3. the initial game board with pieces on it, which is configurable through {@link Configuration#addInitialPiece(Piece, Place)}\n * 4. the two players.\n */\npublic class Configuration implements Cloneable {\n    /**\n     * Size of gameboard.\n     * The gameboard has equal size in width and height.\n     * The size should be an odd number.\n     */\n    private final int size;\n\n    /**\n     * An array of two players in the game.\n     * Note that in the implementation of {@link Game#start()} the first player in this array moves first when game\n     * starts.\n     */\n    private Player[] players;\n\n    /**\n     * The initial map of the gameboard, containing initial pieces and their places.\n     * This map has keys for all places in the gameboard, with or without pieces.\n     * If there is no piece in one place, the place is mapped to null.\n     */\n    private Piece[][] initialBoard;\n\n    /**\n     * The central square of the gameboard.\n     */\n    private Place centralPlace;\n\n    /**\n     * This number means: within the first {@code numMovesProtection} number of moves in the game, capturing\n     * {@link Piece}s is not allowed.\n     */\n    private final int numMovesProtection;\n\n    /**\n     * Constructor of configuration\n     *\n     * @param size size of the gameboard.\n     * @param players an array of two players in the game, the first player should move first when game starts.\n     * @param numMovesProtection the first number of moves where capturing pieces is not allowed\n     */\n    public Configuration(int size, Player[] players, int numMovesProtection) {\n        // validate size\n        if (size < 3) {\n            throw new InvalidConfigurationError(\"size of gameboard must be at least 3\");\n        }\n        if (size % 2 != 1) {\n            throw new InvalidConfigurationError(\"size of gameboard must be an odd number\");\n        }\n        if (size > 25) {\n            throw new InvalidConfigurationError(\"size of gameboard is at most 25\");\n        }\n        this.size = size;\n        // We only have 2 players\n        this.players = players;\n        if (players.length != 2) {\n            throw new InvalidConfigurationError(\"there must be exactly two players\");\n        }\n        // initialize map of the game board by putting every place null (meaning no piece)\n        this.initialBoard = new Piece[size][];\n        for (int x = 0; x < size; x++) {\n            this.initialBoard[x] = new Piece[size];\n            for (int y = 0; y < size; y++) {\n                this.initialBoard[x][y] = null;\n            }\n        }\n        // calculate the central place\n        this.centralPlace = new Place(size / 2, size / 2);\n\n        if (numMovesProtection < 0) {\n            throw new InvalidConfigurationError(\"number of moves with capture protection cannot be negative\");\n        }\n        this.numMovesProtection = numMovesProtection;\n    }\n\n    public Configuration(int size, Player[] players) {\n        this(size, players, 0);\n    }\n\n    /**\n     * Add piece to the initial gameboard.\n     * The player that this piece belongs to will be automatically added into the configuration.\n     *\n     * @param piece piece to be added\n     * @param place place to put the piece\n     */\n    public void addInitialPiece(Piece piece, Place place) {\n        if (!piece.getPlayer().equals(this.players[0]) && !piece.getPlayer().equals(this.players[1])) {\n            throw new InvalidConfigurationError(\"the player of the piece is unknown\");\n        }\n        if (place.x() >= this.size || place.y() >= this.size) {\n            // The place must be inside the gameboard\n            throw new InvalidConfigurationError(\"the place\" + place.toString() + \" must be inside the gameboard\");\n        }\n        if (place.equals(this.centralPlace)) {\n            throw new InvalidConfigurationError(\"piece cannot be put at central place initially\");\n        }\n\n        // put the piece on the initial board\n        this.initialBoard[place.x()][place.y()] = piece;\n    }\n\n    public void addInitialPiece(Piece piece, int x, int y) {\n        this.addInitialPiece(piece, new Place(x, y));\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public Player[] getPlayers() {\n        return players;\n    }\n\n    public Piece[][] getInitialBoard() {\n        return initialBoard;\n    }\n\n    public Place getCentralPlace() {\n        return centralPlace;\n    }\n\n    public int getNumMovesProtection() {\n        return numMovesProtection;\n    }\n\n    @Override\n    public Configuration clone() throws CloneNotSupportedException {\n        Configuration cloned = (Configuration) super.clone();\n        cloned.players = this.players.clone();\n        for (int i = 0; i < this.players.length; i++) {\n            cloned.players[i] = this.players[i].clone();\n        }\n        cloned.initialBoard = this.initialBoard.clone();\n        for (int i = 0; i < this.size; i++) {\n            cloned.initialBoard[i] = this.initialBoard[i].clone();\n            // no need to deep copy piece\n            System.arraycopy(this.initialBoard[i], 0, cloned.initialBoard[i], 0, this.size);\n        }\n        cloned.centralPlace = this.centralPlace.clone();\n        return cloned;\n    }\n}\n\n```\n\n```java\npackage assignment.protocol;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\n/**\n * The Game class\n */\npublic abstract class Game implements Cloneable {\n    /**\n     * Game configuration\n     */\n    protected Configuration configuration;\n\n    /**\n     * The gameboard, which is a 2-dimensional array of {@link Piece}, representing all the {@link Place} (squares) on\n     * the board.\n     * If there is a piece in some {@link Place} place(x,y), then {@code board[place.x()][place.y()]} will be the\n     * piece object, otherwise null.\n     * In other words, the board is a 2-D array with length equal to size of the board in both dimensions.\n     */\n    protected Piece[][] board;\n\n    /**\n     * Current player who is supposed to make a move.\n     */\n    protected Player currentPlayer;\n\n    /**\n     * The current number of moves made by two players\n     */\n    protected int numMoves = 0;\n\n    public Game(Configuration configuration) {\n        this.configuration = "}
{"task_id": "PA20/Knight.java", "target": "assignment/piece/Knight.java", "code": "```java\npackage assignment.piece;\n\nimport assignment.piece.FirstNMovesProtectionRule;\nimport assignment.piece.KnightBlockRule;\nimport assignment.piece.KnightMoveRule;\nimport assignment.piece.NilMoveRule;\nimport assignment.piece.OccupiedRule;\nimport assignment.piece.OutOfBoundaryRule;\nimport assignment.piece.Rule;\nimport assignment.piece.VacantRule;\nimport assignment.protocol.Configuration;\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\nimport assignment.protocol.Piece;\nimport assignment.protocol.Place;\nimport assignment.protocol.Player;\n\nimport java.util.*;\nimport java.util.function.IntFunction;\nimport java.util.function.Predicate;\nimport java.util.stream.Stream;\n\n/**\n * Knight piece that moves similar to knight in chess.\n * Rules of move of Knight can be found in wikipedia (https://en.wikipedia.org/wiki/Knight_(chess)).\n *\n * @see <a href='https://en.wikipedia.org/wiki/Knight_(chess)'>Wikipedia</a>\n */\npublic class Knight extends Piece {\n    public Knight(Player player) {\n        super(player);\n    }\n\n    @Override\n    public char getLabel() {\n        return 'K';\n    }\n\n    /**\n     * Returns an array of moves that are valid given the current place of the piece.\n     * Given the {@link Game} object and the {@link Place} that current knight piece locates, this method should\n     * return ALL VALID {@link Move}s according to the current {@link Place} of this knight piece.\n     * All the returned {@link Move} should have source equal to the source parameter.\n     * <p>\n     * Hint: you should consider corner cases when the {@link Move} is not valid on the gameboard.\n     * Several tests are provided and your implementation should pass them.\n     * <p>\n     * <strong>Attention: Student should make sure all {@link Move}s returned are valid.</strong>\n     *\n     * @param game   the game object\n     * @param source the current place of the piece\n     * @return an array of available moves\n     */\n    @Override\n    public Move[] getAvailableMoves(Game game, Place source) {\n        // TODO student implementation\n        return new Move[0];\n    }\n}\n\n```\n", "code_context": "```java\npackage assignment.piece;\n\nimport assignment.piece.Rule;\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\nimport assignment.protocol.Piece;\nimport assignment.protocol.Place;\n\n/**\n * The rule that requires capturing piece is not allowed within the first certain number of moves.\n */\npublic class FirstNMovesProtectionRule implements Rule {\n    /**\n     * The number of moves within which capturing piece is not allowed.\n     */\n    private final int numProtectedMoves;\n\n    public FirstNMovesProtectionRule(int numProtectedMoves) {\n        this.numProtectedMoves = numProtectedMoves;\n    }\n\n    @Override\n    public boolean validate(Game game, Move move) {\n        // TODO\n        return false;\n    }\n\n    @Override\n    public String getDescription() {\n        return \"Capturing piece in the first \" + this.numProtectedMoves + \" moves are not allowed\";\n    }\n}\n\n```\n\n```java\npackage assignment.piece;\n\nimport assignment.piece.Knight;\nimport assignment.piece.Rule;\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\nimport assignment.protocol.Piece;\nimport assignment.protocol.Place;\n\n/**\n * The blocking rule applying on Knights. The rule is similar to the blocking rule for horse in Chinese chess.\n * The horse does not jump as the knight does in Western chess, and can be blocked by a piece of either colour located one point horizontally or vertically adjacent to it\n */\npublic class KnightBlockRule implements Rule {\n    @Override\n    public boolean validate(Game game, Move move) {\n        if (!(game.getPiece(move.getSource()) instanceof Knight)) {\n            return true;\n        }\n        // TODO student implementation\n        return false;\n    }\n\n    @Override\n    public String getDescription() {\n        return \"knight is blocked by another piece\";\n    }\n}\n\n```\n\n```java\npackage assignment.piece;\n\nimport assignment.piece.Knight;\nimport assignment.piece.Rule;\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\nimport assignment.protocol.Piece;\nimport assignment.protocol.Place;\n\n/**\n * Moving rule of Knight in chess (no block)\n * It moves two squares vertically and one square horizontally, or two squares horizontally and one square vertically\n */\npublic class KnightMoveRule implements Rule {\n\n    @Override\n    public boolean validate(Game game, Move move) {\n        if (!(game.getPiece(move.getSource()) instanceof Knight)) {\n            return true;\n        }\n        // TODO student implementation\n        return false;\n    }\n\n    @Override\n    public String getDescription() {\n        return \"knight move rule is violated\";\n    }\n}\n\n```\n\n```java\npackage assignment.piece;\n\nimport assignment.piece.Rule;\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\nimport assignment.protocol.Place;\n\n/**\n * Global rule that requires the source and destination of a move should not be the same.\n */\npublic class NilMoveRule implements Rule {\n    @Override\n    public boolean validate(Game game, Move move) {\n        // TODO\n        return false;\n    }\n\n    @Override\n    public String getDescription() {\n        return \"the source and destination of move should be different places\";\n    }\n}\n\n```\n\n```java\npackage assignment.piece;\n\nimport assignment.piece.Rule;\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\nimport assignment.protocol.Piece;\nimport assignment.protocol.Place;\nimport assignment.protocol.Player;\n\n/**\n * Global rule that requires that a piece should not go to a destination where there is another piece belonging to the\n * same player.\n */\npublic class OccupiedRule implements Rule {\n    @Override\n    public boolean validate(Game game, Move move) {\n        // TODO\n        return false;\n    }\n\n    @Override\n    public String getDescription() {\n        return \"piece cannot be captured by another piece belonging to the same player\";\n    }\n}\n\n```\n\n```java\npackage assignment.piece;\n\nimport assignment.piece.Rule;\nimport assignment.protocol.Configuration;\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\nimport assignment.protocol.Place;\n\n/**\n * Global rule that requires the source and destination should be inside the board boundary.\n */\npublic class OutOfBoundaryRule implements Rule {\n    @Override\n    public boolean validate(Game game, Move move) {\n        // TODO\n        return false;\n    }\n\n    @Override\n    public String getDescription() {\n        return \"place is out of boundary of gameboard\";\n    }\n}\n\n```\n\n```java\npackage assignment.piece;\n\n\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\n\n/**\n * Interface that a rule should implement.\n * Every mode in the gameboard should not violate the rule.\n */\npublic interface Rule {\n    /**\n     * Validate the move. if the rule is violated return false.\n     * <p>\n     * [Hint] the piece that is to be moved can be obtained using {@code game.getPiece(move.getSource()}.\n     *\n     * @param game the current game object\n     * @param move the move to be validated\n     * @return true if the rule check pass. If the rule is violated, return false.\n     */\n    public boolean validate(Game game, Move move);\n\n    /**\n     * Returns a string description of the rule, which will be printed as error message when the rule is violated.\n     *\n     * @return description of the rule\n     */\n    public String getDescription();\n}\n\n// Below are several predefined global rules for all moves.\n\n\n```\n\n```java\npackage assignment.piece;\n\nimport assignment.piece.Rule;\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\nimport assignment.protocol.Piece;\nimport assignment.protocol.Place;\n\n/**\n * Global rule that requires the source place of a move must have a piece on it.\n */\npublic class VacantRule implements Rule {\n    @Override\n    public boolean validate(Game game, Move move) {\n        // TODO student implementation\n        return false;\n    }\n\n    @Override\n    public String getDescription() {\n        return \"the source of move should have a piece\";\n    }\n}\n\n```\n\n```java\npackage assignment.protocol;\n\nimport assignment.protocol.exception.InvalidConfigurationError;\n\n/**\n * Game configuration, including:\n * 1. size of gameboard\n * 2. place (square) of central square in classical Jeson Mor\n * 3. the initial game board with pieces on it, which is configurable through {@link Configuration#addInitialPiece(Piece, Place)}\n * 4. the two players.\n */\npublic class Configuration implements Cloneable {\n    /**\n     * Size of gameboard.\n     * The gameboard has equal size in width and height.\n     * The size should be an odd number.\n     */\n    private final int size;\n\n    /**\n     * An array of two players in the game.\n     * Note that in the implementation of {@link Game#start()} the first player in this array moves first when game\n     * starts.\n     */\n    private Player[] players;\n\n    /**\n     * The initial map of the gameboard, containing initial pieces and their places.\n     * This map has keys for all places in the gameboard, with or without pieces.\n     * If there is no piece in one place, the place is mapped to null.\n     */\n    private Piece[][] initialBoard;\n\n    /**\n     * The central square of the gameboard.\n     */\n    private Place centralPlace;\n\n    /**\n     * This number means: within the first {@code numMovesProtection} number of moves in the game, capturing\n     * {@link Piece}s is not allowed.\n     */\n    private final int numMovesProtection;\n\n    /**\n     * Constructor of configuration\n     *\n     * @param size size of the gameboard.\n     * @param players an array of two players in the game, the first player should move first when game starts.\n     * @param numMovesProtection the first number of moves where capturing pieces is not allowed\n     */\n    public Configuration(int size, Player[] players, int numMovesProtection) {\n        // validate size\n        if (size < 3) {\n            throw new InvalidConfigurationError(\"size of gameboard must be at least 3\");\n        }\n        if (size % 2 != 1) {\n            throw new InvalidConfigurationError(\"size of gameboard must be an odd number\");\n        }\n        if (size > 25) {\n            throw new InvalidConfigurationError(\"size of gameboard is at most 25\");\n        }\n        this.size = size;\n        // We only have 2 players\n        this.players = players;\n        if (players.length != 2) {\n            throw new InvalidConfigurationError(\"there must be exactly two players\");\n        }\n        // initialize map of the game board by putting every place null (meaning no piece)\n        this.initialBoard = new Piece[size][];\n        for (int x = 0; x < size; x++) {\n            this.initialBoard[x] = new Piece[size];\n            for (int y = 0; y < size; y++) {\n                this.initialBoard[x][y] = null;\n            }\n        }\n        // calculate the central place\n        this.centralPlace = new Place(size / 2, size / 2);\n\n        if (numMovesProtection < 0) {\n            throw new InvalidConfigurationError(\"number of moves with capture protection cannot be negative\");\n        }\n        this.numMovesProtection = numMovesProtection;\n    }\n\n    public Configuration(int size, Player[] players) {\n        this(size, players, 0);\n    }\n\n    /**\n     * Add piece to the initial gameboard.\n     * The player that this piece belongs to will be automatically added into the configuration.\n     *\n     * @param piece piece to be added\n     * @param place place to put the piece\n     */\n    public void addInitialPiece(Piece piece, Place place) {\n        if (!piece.getPlayer().equals(this.players[0]) && !piece.getPlayer().equals(this.players[1])) {\n            throw new InvalidConfigurationError(\"the player of the piece is unknown\");\n        }\n        if (place.x() >= this.size || place.y() >= this.size) {\n            // The place must be inside the gameboard\n            throw new InvalidConfigurationError(\"the place\" + place.toString() + \" must be inside the gameboard\");\n        }\n        if (place.equals(this.centralPlace)) {\n            throw new InvalidConfigurationError(\"piece cannot be put at central place initially\");\n        }\n\n        // put the piece on the initial board\n        this.initialBoard[place.x()][place.y()] = piece;\n    }\n\n    public void addInitialPiece(Piece piece, int x, int y) {\n        this.addInitialPiece(piece, new Place(x, y));\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public Player[] getPlayers() {\n        return players;\n    }\n\n    public Piece[][] getInitialBoard() {\n        return initialBoard;\n    }\n\n    public Place getCentralPlace() {\n        return centralPlace;\n    }\n\n    public int getNumMovesProtection() {\n        return numMovesProtection;\n    }\n\n    @Override\n    public Configuration clone() throws CloneNotSupportedException {\n        Configuration cloned = (Configuration) super.clone();\n        cloned.players = this.players.clone();\n        for (int i = 0; i < this.players.length; i++) {\n            cloned.players[i] = this.players[i].clone();\n        }\n        cloned.initialBoard = this.initialBoard.clone();\n        for (int i = 0; i < this.size; i++) {\n            cloned.initialBoard[i] = this.initialBoard[i].clone();\n            // no need to deep copy piece\n            System.arraycopy(this.initialBoard[i], 0, cloned.initialBoard[i], 0, this.size);\n        }\n        cloned.centralPlace = this.centralPlace.clone();\n        return cloned;\n    }\n}\n\n```\n\n```java\npackage assignment.protocol;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\n/**\n"}
{"task_id": "PA20/ConsolePlayer.java", "target": "assignment/player/ConsolePlayer.java", "code": "```java\npackage assignment.player;\n\nimport assignment.piece.ArcherMoveRule;\nimport assignment.piece.FirstNMovesProtectionRule;\nimport assignment.piece.KnightBlockRule;\nimport assignment.piece.KnightMoveRule;\nimport assignment.piece.NilMoveRule;\nimport assignment.piece.OccupiedRule;\nimport assignment.piece.OutOfBoundaryRule;\nimport assignment.piece.Rule;\nimport assignment.piece.VacantRule;\nimport assignment.protocol.Color;\nimport assignment.protocol.Configuration;\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\nimport assignment.protocol.Piece;\nimport assignment.protocol.Place;\nimport assignment.protocol.Player;\n\nimport java.io.*;\nimport java.util.Scanner;\n\n/**\n * The player that makes move according to user input from console.\n */\npublic class ConsolePlayer extends Player {\n    public ConsolePlayer(String name, Color color) {\n        super(name, color);\n    }\n\n    public ConsolePlayer(String name) {\n        this(name, Color.GREEN);\n    }\n\n    /**\n     * Choose a move from available moves.\n     * This method will be called by {@link Game} object to get the move that the player wants to make when it is the\n     * player's turn.\n     * <p>\n     * {@link ConsolePlayer} returns a move according to user's input in the console.\n     * The console input format should conform the format described in the assignment description.\n     * (e.g. {@literal a1->b3} means move the {@link Piece} at {@link Place}(x=0,y=0) to {@link Place}(x=1,y=2))\n     * Note that in the {@link Game}.board, the index starts from 0 in both x and y dimension, while in the console\n     * display, x dimension index starts from 'a' and y dimension index starts from 1.\n     * <p>\n     * Hint: be sure to handle invalid input to avoid invalid {@link Move}s.\n     * <p>\n     * <strong>Attention: Student should make sure the {@link Move} returned is valid.</strong>\n     * <p>\n     * <strong>Attention: {@link Place} object uses integer as index of x and y-axis, both starting from 0 to\n     * facilitate programming.\n     * This is VERY different from the coordinate used in console display.</strong>\n     *\n     * @param game           the current game object\n     * @param availableMoves available moves for this player to choose from.\n     * @return the chosen move\n     */\n    @Override\n    public Move nextMove(Game game, Move[] availableMoves) {\n        // TODO student implementation\n        return availableMoves[0];\n    }\n}\n\n```\n", "code_context": "```java\npackage assignment.piece;\n\nimport assignment.piece.Archer;\nimport assignment.piece.Rule;\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\nimport assignment.protocol.Piece;\nimport assignment.protocol.Place;\nimport assignment.protocol.Player;\n\n/**\n * The rule of moving of Archer, which is similar to the moving rule of cannon in Chinese chess.\n * Cannons move like chariots, any distance orthogonally without jumping, but can only capture by jumping a single piece of either colour along the path of attack.\n */\npublic class ArcherMoveRule implements Rule {\n    @Override\n    public boolean validate(Game game, Move move) {\n        if (!(game.getPiece(move.getSource()) instanceof Archer)) {\n            return true;\n        }\n        // TODO student implementation\n        return false;\n    }\n\n    @Override\n    public String getDescription() {\n        return \"archer move rule is violated\";\n    }\n}\n\n```\n\n```java\npackage assignment.piece;\n\nimport assignment.piece.Rule;\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\nimport assignment.protocol.Piece;\nimport assignment.protocol.Place;\n\n/**\n * The rule that requires capturing piece is not allowed within the first certain number of moves.\n */\npublic class FirstNMovesProtectionRule implements Rule {\n    /**\n     * The number of moves within which capturing piece is not allowed.\n     */\n    private final int numProtectedMoves;\n\n    public FirstNMovesProtectionRule(int numProtectedMoves) {\n        this.numProtectedMoves = numProtectedMoves;\n    }\n\n    @Override\n    public boolean validate(Game game, Move move) {\n        // TODO\n        return false;\n    }\n\n    @Override\n    public String getDescription() {\n        return \"Capturing piece in the first \" + this.numProtectedMoves + \" moves are not allowed\";\n    }\n}\n\n```\n\n```java\npackage assignment.piece;\n\nimport assignment.piece.Knight;\nimport assignment.piece.Rule;\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\nimport assignment.protocol.Piece;\nimport assignment.protocol.Place;\n\n/**\n * The blocking rule applying on Knights. The rule is similar to the blocking rule for horse in Chinese chess.\n * The horse does not jump as the knight does in Western chess, and can be blocked by a piece of either colour located one point horizontally or vertically adjacent to it\n */\npublic class KnightBlockRule implements Rule {\n    @Override\n    public boolean validate(Game game, Move move) {\n        if (!(game.getPiece(move.getSource()) instanceof Knight)) {\n            return true;\n        }\n        // TODO student implementation\n        return false;\n    }\n\n    @Override\n    public String getDescription() {\n        return \"knight is blocked by another piece\";\n    }\n}\n\n```\n\n```java\npackage assignment.piece;\n\nimport assignment.piece.Knight;\nimport assignment.piece.Rule;\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\nimport assignment.protocol.Piece;\nimport assignment.protocol.Place;\n\n/**\n * Moving rule of Knight in chess (no block)\n * It moves two squares vertically and one square horizontally, or two squares horizontally and one square vertically\n */\npublic class KnightMoveRule implements Rule {\n\n    @Override\n    public boolean validate(Game game, Move move) {\n        if (!(game.getPiece(move.getSource()) instanceof Knight)) {\n            return true;\n        }\n        // TODO student implementation\n        return false;\n    }\n\n    @Override\n    public String getDescription() {\n        return \"knight move rule is violated\";\n    }\n}\n\n```\n\n```java\npackage assignment.piece;\n\nimport assignment.piece.Rule;\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\nimport assignment.protocol.Place;\n\n/**\n * Global rule that requires the source and destination of a move should not be the same.\n */\npublic class NilMoveRule implements Rule {\n    @Override\n    public boolean validate(Game game, Move move) {\n        // TODO\n        return false;\n    }\n\n    @Override\n    public String getDescription() {\n        return \"the source and destination of move should be different places\";\n    }\n}\n\n```\n\n```java\npackage assignment.piece;\n\nimport assignment.piece.Rule;\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\nimport assignment.protocol.Piece;\nimport assignment.protocol.Place;\nimport assignment.protocol.Player;\n\n/**\n * Global rule that requires that a piece should not go to a destination where there is another piece belonging to the\n * same player.\n */\npublic class OccupiedRule implements Rule {\n    @Override\n    public boolean validate(Game game, Move move) {\n        // TODO\n        return false;\n    }\n\n    @Override\n    public String getDescription() {\n        return \"piece cannot be captured by another piece belonging to the same player\";\n    }\n}\n\n```\n\n```java\npackage assignment.piece;\n\nimport assignment.piece.Rule;\nimport assignment.protocol.Configuration;\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\nimport assignment.protocol.Place;\n\n/**\n * Global rule that requires the source and destination should be inside the board boundary.\n */\npublic class OutOfBoundaryRule implements Rule {\n    @Override\n    public boolean validate(Game game, Move move) {\n        // TODO\n        return false;\n    }\n\n    @Override\n    public String getDescription() {\n        return \"place is out of boundary of gameboard\";\n    }\n}\n\n```\n\n```java\npackage assignment.piece;\n\n\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\n\n/**\n * Interface that a rule should implement.\n * Every mode in the gameboard should not violate the rule.\n */\npublic interface Rule {\n    /**\n     * Validate the move. if the rule is violated return false.\n     * <p>\n     * [Hint] the piece that is to be moved can be obtained using {@code game.getPiece(move.getSource()}.\n     *\n     * @param game the current game object\n     * @param move the move to be validated\n     * @return true if the rule check pass. If the rule is violated, return false.\n     */\n    public boolean validate(Game game, Move move);\n\n    /**\n     * Returns a string description of the rule, which will be printed as error message when the rule is violated.\n     *\n     * @return description of the rule\n     */\n    public String getDescription();\n}\n\n// Below are several predefined global rules for all moves.\n\n\n```\n\n```java\npackage assignment.piece;\n\nimport assignment.piece.Rule;\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\nimport assignment.protocol.Piece;\nimport assignment.protocol.Place;\n\n/**\n * Global rule that requires the source place of a move must have a piece on it.\n */\npublic class VacantRule implements Rule {\n    @Override\n    public boolean validate(Game game, Move move) {\n        // TODO student implementation\n        return false;\n    }\n\n    @Override\n    public String getDescription() {\n        return \"the source of move should have a piece\";\n    }\n}\n\n```\n\n```java\npackage assignment.protocol;\n\npublic enum Color {\n    DEFAULT(\"\\u001B[0m\"),\n    BLACK(\"\\u001B[30m\"),\n    RED(\"\\u001B[31m\"),\n    GREEN(\"\\u001B[32m\"),\n    YELLOW(\"\\u001B[33m\"),\n    BLUE(\"\\u001B[34m\"),\n    PURPLE(\"\\u001B[35m\"),\n    CYAN(\"\\u001B[36m\"),\n    WHITE(\"\\u001B[37m\");\n\n    private final String ansiColor;\n\n    Color(String ansiColor) {\n        this.ansiColor = ansiColor;\n    }\n\n    public String toString() {\n        return ansiColor;\n    }\n}\n```\n\n```java\npackage assignment.protocol;\n\nimport assignment.protocol.exception.InvalidConfigurationError;\n\n/**\n * Game configuration, including:\n * 1. size of gameboard\n * 2. place (square) of central square in classical Jeson Mor\n * 3. the initial game board with pieces on it, which is configurable through {@link Configuration#addInitialPiece(Piece, Place)}\n * 4. the two players.\n */\npublic class Configuration implements Cloneable {\n    /**\n     * Size of gameboard.\n     * The gameboard has equal size in width and height.\n     * The size should be an odd number.\n     */\n    private final int size;\n\n    /**\n     * An array of two players in the game.\n     * Note that in the implementation of {@link Game#start()} the first player in this array moves first when game\n     * starts.\n     */\n    private Player[] players;\n\n    /**\n     * The initial map of the gameboard, containing initial pieces and their places.\n     * This map has keys for all places in the gameboard, with or without pieces.\n     * If there is no piece in one place, the place is mapped to null.\n     */\n    private Piece[][] initialBoard;\n\n    /**\n     * The central square of the gameboard.\n     */\n    private Place centralPlace;\n\n    /**\n     * This number means: within the first {@code numMovesProtection} number of moves in the game, capturing\n     * {@link Piece}s is not allowed.\n     */\n    private final int numMovesProtection;\n\n    /**\n     * Constructor of configuration\n     *\n     * @param size size of the gameboard.\n     * @param players an array of two players in the game, the first player should move first when game starts.\n     * @param numMovesProtection the first number of moves where capturing pieces is not allowed\n     */\n    public Configuration(int size, Player[] players, int numMovesProtection) {\n        // validate size\n        if (size < 3) {\n            throw new InvalidConfigurationError(\"size of gameboard must be at least 3\");\n        }\n        if (size % 2 != 1) {\n            throw new InvalidConfigurationError(\"size of gameboard must be an odd number\");\n        }\n        if (size > 25) {\n            throw new InvalidConfigurationError(\"size of gameboard is at most 25\");\n        }\n        this.size = size;\n        // We only have 2 players\n        this.players = players;\n        if (players.length != 2) {\n            throw new InvalidConfigurationError(\"there must be exactly two players\");\n        }\n        // initialize map of the game board by putting every place null (meaning no piece)\n        this.initialBoard = new Piece[size][];\n        for (int x = 0; x < size; x++) {\n            this.initialBoard[x] = new Piece[size];\n            for (int y = 0; y < size; y++) {\n                this.initialBoard[x][y] = null;\n            }\n        }\n        // calculate the central place\n        this.centralPlace = new Place(size / 2, size / 2);\n\n        if (numMovesProtection < 0) {\n            throw new InvalidConfigurationError(\"number of moves with capture protection cannot be negative\");\n        }\n        this.numMovesProtection = numMovesProtection;\n    }\n\n    public Configuration(int size, Player[] players) {\n        this(size, players, 0);\n    }\n\n    /**\n     * Add piece to the initial gameboard.\n     * The player that this piece belongs to will be automatically added into the configuration.\n     *\n     * @param piece piece to be added\n     * @param place place to put the piece\n     */\n    public void addInitialPiece(Piece piece, Place place) {\n        if (!piece.getPlayer().equals(this.players[0]) && !piece.getPlayer().equals(this.players[1])) {\n            throw new InvalidConfigurationError(\"the player of the piece is unknown\");\n        }\n        if (place.x() >= this.size || place.y() >= this.size) {\n            // The place must be inside the gameboard\n            throw new InvalidConfigurationError(\"the place\" + place.toString() + \" must be inside the gameboard\");\n        }\n        if (place.equals(this.centralPlace))"}
{"task_id": "PA20/RandomPlayer.java", "target": "assignment/player/RandomPlayer.java", "code": "```java\npackage assignment.player;\n\nimport assignment.protocol.Game;\nimport assignment.protocol.Color;\nimport assignment.protocol.Move;\nimport assignment.protocol.Player;\n\nimport java.util.Random;\n\n/**\n * A computer player that makes a move randomly.\n */\npublic class RandomPlayer extends Player {\n    public RandomPlayer(String name, Color color) {\n        super(name, color);\n    }\n\n    public RandomPlayer(String name) {\n        this(name, Color.BLUE);\n    }\n\n    /**\n     * Choose a move from available moves.\n     * This method will be called by {@link Game} object to get the move that the player wants to make when it is the\n     * player's turn.\n     * <p>\n     * {@link RandomPlayer} chooses a move from available ones randomly.\n     * <p>\n     * <strong>Attention: Student should make sure the {@link Move} returned is valid.</strong>\n     *\n     * @param game           the current game object\n     * @param availableMoves available moves for this player to choose from.\n     * @return the chosen move\n     */\n    @Override\n    public Move nextMove(Game game, Move[] availableMoves) {\n        // TODO student implementation\n        return availableMoves[0];\n    }\n}\n\n```\n", "code_context": "```java\npackage assignment.protocol;\n\npublic enum Color {\n    DEFAULT(\"\\u001B[0m\"),\n    BLACK(\"\\u001B[30m\"),\n    RED(\"\\u001B[31m\"),\n    GREEN(\"\\u001B[32m\"),\n    YELLOW(\"\\u001B[33m\"),\n    BLUE(\"\\u001B[34m\"),\n    PURPLE(\"\\u001B[35m\"),\n    CYAN(\"\\u001B[36m\"),\n    WHITE(\"\\u001B[37m\");\n\n    private final String ansiColor;\n\n    Color(String ansiColor) {\n        this.ansiColor = ansiColor;\n    }\n\n    public String toString() {\n        return ansiColor;\n    }\n}\n```\n\n```java\npackage assignment.protocol;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\n/**\n * The Game class\n */\npublic abstract class Game implements Cloneable {\n    /**\n     * Game configuration\n     */\n    protected Configuration configuration;\n\n    /**\n     * The gameboard, which is a 2-dimensional array of {@link Piece}, representing all the {@link Place} (squares) on\n     * the board.\n     * If there is a piece in some {@link Place} place(x,y), then {@code board[place.x()][place.y()]} will be the\n     * piece object, otherwise null.\n     * In other words, the board is a 2-D array with length equal to size of the board in both dimensions.\n     */\n    protected Piece[][] board;\n\n    /**\n     * Current player who is supposed to make a move.\n     */\n    protected Player currentPlayer;\n\n    /**\n     * The current number of moves made by two players\n     */\n    protected int numMoves = 0;\n\n    public Game(Configuration configuration) {\n        this.configuration = configuration;\n        this.board = configuration.getInitialBoard();\n    }\n\n    /**\n     * Start the game\n     * Players will take turns according to the order in {@link Configuration#getPlayers()} to make a move until\n     * a player wins.\n     *\n     * @return the winner\n     */\n    public abstract Player start();\n\n    /**\n     * Get the winner of the game. If there is no winner yet, return null;\n     *\n     * @param lastPlayer the last player who makes a move\n     * @param lastPiece the last piece that is moved by the player\n     * @param lastMove   the last move made by lastPlayer\n     * @return the winner if it exists, otherwise return null\n     */\n    public abstract Player getWinner(Player lastPlayer, Piece lastPiece, Move lastMove);\n\n    /**\n     * Update the score of a player according to the piece and corresponding move made by him just now.\n     *\n     * @param player the player who just makes a move\n     * @param piece  the piece that is just moved\n     * @param move   the move that is just made\n     */\n    public abstract void updateScore(Player player, Piece piece, Move move);\n\n    /**\n     * Make a move.\n     *\n     * @param move the move to make\n     */\n    public abstract void movePiece(Move move);\n\n    /**\n     * Get all available moves of one player.\n     *\n     * @param player the player whose available moves to get\n     * @return an array of available moves\n     */\n    public abstract Move[] getAvailableMoves(Player player);\n\n    /**\n     * Refresh the output printed in the console, which shows the following things.\n     * 1. the gameboard and pieces on it\n     * 2. scores of the players\n     * 3. other help information\n     */\n    public void refreshOutput() {\n        int size = this.configuration.getSize();\n        ArrayList<List<String>> contents = new ArrayList<List<String>>();\n        for (int row = size - 1; row >= 0; row--) {\n            ArrayList<String> rowContent = new ArrayList<String>();\n            for (int col = 0; col < size; col++) {\n                Piece piece = this.getPiece(col, row);\n                if (piece == null) {\n                    if (this.getCentralPlace().equals(new Place(col, row))) {\n                        rowContent.add(\"x\");\n                    } else {\n                        rowContent.add(\".\");\n                    }\n                } else {\n                    Player player = piece.getPlayer();\n                    rowContent.add(String.format(\"%s%c%s\",\n                            player.getColor(),\n                            piece.getLabel(),\n                            Color.DEFAULT));\n                }\n            }\n            contents.add(rowContent);\n        }\n        ArrayList<String> xCoordinates = new ArrayList<String>();\n        for (int i = 0; i < size; i++) {\n            xCoordinates.add(String.valueOf((char) ('a' + i)));\n        }\n        Collections.reverse(contents);\n\n        // clear screen\n        System.out.print(\"\\u001b[2J\");\n        System.out.flush();\n\n        System.out.println();\n        System.out.println(\"### COMP3021 Programming Assignment 1 ###\");\n        System.out.println();\n        System.out.println(\"Guide: to move a piece, input the coordinate of source and the destination.\");\n        System.out.println(\"For example: a1->b2 means to move the piece at 'a1' to 'b2'\");\n        if (this.numMoves < this.configuration.getNumMovesProtection()) {\n            System.out.println();\n            System.out.println(\"Notice: first \" + this.configuration.getNumMovesProtection() + \" moves are not allowed to\" +\n                    \" capture pieces or win the game.\");\n        }\n        System.out.println();\n        System.out.println(\"Total Moves: \" + this.numMoves);\n        // print scores of players\n        for (Player player :\n                this.configuration.getPlayers()) {\n            System.out.printf(\"%s%s%s score: %d\\n\", player.getColor(), player.getName(), Color.DEFAULT,\n                    player.getScore());\n        }\n        System.out.println();\n        // print the gameboard\n        int leftPadding = 8;\n        StringBuilder paddingSpaceBuilder = new StringBuilder();\n        paddingSpaceBuilder.append(\" \".repeat(leftPadding));\n        System.out.printf(\"%s%s\\n\",\n                paddingSpaceBuilder.toString(),\n                xCoordinates.parallelStream()\n                        .collect(Collectors.joining(\" \")));\n        StringBuilder borderBuilder = new StringBuilder();\n        borderBuilder.append(\"-\".repeat(Math.max(0, contents.get(0).size() * 2 - 1)));\n        System.out.printf(\"%s%s\\n\",\n                paddingSpaceBuilder.toString(),\n                borderBuilder.toString());\n        for (int row = contents.size() - 1; row >= 0; row--) {\n            System.out.printf(\"%\" + (leftPadding - 1) + \"d|%s|%d\\n\",\n                    row + 1,\n                    contents.get(row).parallelStream().map(Object::toString).collect(Collectors.joining(\" \")),\n                    row + 1);\n        }\n        System.out.printf(\"%s%s\\n\",\n                paddingSpaceBuilder.toString(),\n                borderBuilder.toString());\n        System.out.printf(\"%s%s\\n\",\n                paddingSpaceBuilder.toString(),\n                xCoordinates.parallelStream()\n                        .collect(Collectors.joining(\" \")));\n        System.out.println();\n    }\n\n    /**\n     * Get the piece in the place\n     *\n     * @param place the place of the piece\n     * @return the piece\n     */\n    public Piece getPiece(Place place) {\n        return this.board[place.x()][place.y()];\n    }\n\n    public Piece getPiece(int x, int y) {\n        return this.getPiece(new Place(x, y));\n    }\n\n    public Player getCurrentPlayer() {\n        return currentPlayer != null ? currentPlayer : this.configuration.getPlayers()[0];\n    }\n\n    public Player[] getPlayers() {\n        return configuration.getPlayers();\n    }\n\n    public int getNumMoves() {\n        return numMoves;\n    }\n\n    public Configuration getConfiguration() {\n        return configuration;\n    }\n\n    public Place getCentralPlace() {\n        return configuration.getCentralPlace();\n    }\n\n    @Override\n    public Game clone() throws CloneNotSupportedException {\n        Game cloned = (Game) super.clone();\n        cloned.configuration = this.configuration.clone();\n        cloned.board = this.board.clone();\n        for (int i = 0; i < this.configuration.getSize(); i++) {\n            cloned.board[i] = this.board[i].clone();\n            // no need to deep copy pieces\n            if (this.configuration.getSize() >= 0)\n                System.arraycopy(this.board[i], 0, cloned.board[i], 0, this.configuration.getSize());\n        }\n        cloned.currentPlayer = currentPlayer == null ? null : currentPlayer.clone();\n        return cloned;\n    }\n}\n```\n\n```java\npackage assignment.protocol;\n\nimport java.util.Objects;\nimport java.util.StringJoiner;\n\n/**\n * Move class represent a move made by a {@link Player}, moving a piece from one {@link Place} to another {@link Place}.\n */\npublic class Move implements Cloneable {\n    /**\n     * Source place of the move.\n     */\n    private Place source;\n\n    /**\n     * Move destination\n     */\n    private Place destination;\n\n    public Move(Place source, Place destination) {\n        this.source = source;\n        this.destination = destination;\n    }\n\n    public Move(int sourceX, int sourceY, int destinationX, int destinationY) {\n        this(new Place(sourceX, sourceY), new Place(destinationX, destinationY));\n    }\n\n    public Move(Place source, int destinationX, int destinationY) {\n        this(source, new Place(destinationX, destinationY));\n    }\n\n    /* Getters start */\n    public Place getSource() {\n        return source;\n    }\n\n    public Place getDestination() {\n        return destination;\n    }\n    /* Getters end */\n\n    /* Object methods start */\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Move move = (Move) o;\n        return source.equals(move.source) &&\n                destination.equals(move.destination);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(source, destination);\n    }\n\n    @Override\n    public String toString() {\n        return new StringJoiner(\", \", Move.class.getSimpleName() + \"[\", \"]\")\n                .add(\"source=\" + source)\n                .add(\"destination=\" + destination)\n                .toString();\n    }\n\n    @Override\n    public Move clone() throws CloneNotSupportedException {\n        Move cloned = (Move) super.clone();\n        cloned.source = this.source.clone();\n        cloned.destination = this.destination.clone();\n        return cloned;\n    }\n\n    /* Object methods end */\n\n}\n\n```\n\n```java\npackage assignment.protocol;\n\nimport java.util.Objects;\n\n/**\n * Player interface for the game.\n * Implementations could be computer player or human player.\n */\npublic abstract class Player implements Cloneable {\n    /**\n     * The name of a player.\n     * By default, name is a unique identifier to distinguish different players. But this can be overrided by\n     * overriding {@link Player#equals(Object)} method.\n     */\n    protected final String name;\n\n    /**\n     * The game score of this player.\n     * Score will be updated whenever the player makes a move through {@link Game#updateScore(Player, Piece, Move)}\n     * and {@link Player#setScore(int)}\n     */\n    protected int score;\n\n    /**\n     * The color representing this player\n     */\n    protected final Color color;\n\n    public Player(String name, Color color) {\n        this.name = name;\n        this.color = color;\n    }\n\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Player player = (Player) o;\n        return name.equals(player.name);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(name);\n    }\n\n    public final String getName() {\n        return this.name;\n    }\n\n    public final int getScore() {\n        return score;\n    }\n\n    public final void setScore(int score) {\n        this.score = score;\n    }\n\n    public String toString() {\n        return this.name;\n    }\n\n    /**\n     * Get color used to represent this player.\n     *\n     * @return color of this player\n     */\n    public final Color getColor() {\n        return this.color;\n    }\n\n    @Override\n    public Player clone() throws CloneNotSupportedException {\n        return (Player) super.clone();\n    }\n\n    /**\n     * Choose a move from available moves.\n     * This method will be called by {@link Game} object to get the move that the player wants to make when it is the\n     * player's turn.\n     *\n     * @param game           th"}
{"task_id": "PA20/JesonMor.java", "target": "assignment/JesonMor.java", "code": "```java\npackage assignment;\n\nimport assignment.piece.Knight;\nimport assignment.protocol.Color;\nimport assignment.protocol.Configuration;\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\nimport assignment.protocol.Piece;\nimport assignment.protocol.Place;\nimport assignment.protocol.Player;\n\nimport java.io.*;\nimport java.util.*;\n\n/**\n * This class extends {@link Game}, implementing the game logic of JesonMor game.\n * Student needs to implement methods in this class to make the game work.\n * Hint: make good use of methods predefined in {@link Game} to get various information to facilitate your work.\n * <p>\n * Several sample tests are provided to test your implementation of each method in the test directory.\n * Please make make sure all tests pass before submitting the assignment.\n */\npublic class JesonMor extends Game {\n    public JesonMor(Configuration configuration) {\n        super(configuration);\n    }\n\n    /**\n     * Start the game\n     * Players will take turns according to the order in {@link Configuration#getPlayers()} to make a move until\n     * a player wins.\n     * <p>\n     * In the implementation, student should implement the loop letting two players take turns to move pieces.\n     * The order of the players should be consistent to the order in {@link Configuration#getPlayers()}.\n     * {@link Player#nextMove(Game, Move[])} should be used to retrieve the player's choice of his next move.\n     * After each move, {@link Game#refreshOutput()} should be called to refresh the gameboard printed in the console.\n     * <p>\n     * When a winner appears, set the local variable {@code winner} so that this method can return the winner.\n     *\n     * @return the winner\n     */\n    @Override\n    public Player start() {\n        // reset all things\n        Player winner = null;\n        this.numMoves = 0;\n        this.board = configuration.getInitialBoard();\n        this.currentPlayer = null;\n        this.refreshOutput();\n        while (true) {\n            // TODO student implementation starts here\n\n            // student implementation ends here\n            if (winner != null) {\n                System.out.println();\n                System.out.println(\"Congratulations! \");\n                System.out.printf(\"Winner: %s%s%s\\n\", winner.getColor(), winner.getName(), Color.DEFAULT);\n                return winner;\n            }\n        }\n    }\n\n    /**\n     * Get the winner of the game. If there is no winner yet, return null;\n     * This method will be called every time after a player makes a move and after\n     * {@link JesonMor#updateScore(Player, Piece, Move)} is called, in order to\n     * check whether any {@link Player} wins.\n     * If this method returns a player (the winner), then the game will exit with the winner.\n     * If this method returns null, next player will be asked to make a move.\n     *\n     * @param lastPlayer the last player who makes a move\n     * @param lastMove   the last move made by lastPlayer\n     * @param lastPiece  the last piece that is moved by the player\n     * @return the winner if it exists, otherwise return null\n     */\n    @Override\n    public Player getWinner(Player lastPlayer, Piece lastPiece, Move lastMove) {\n        // TODO student implementation\n        return null;\n    }\n\n    /**\n     * Update the score of a player according to the {@link Piece} and corresponding move made by him just now.\n     * This method will be called every time after a player makes a move, in order to update the corresponding score\n     * of this player.\n     * <p>\n     * The score of a player is the cumulative score of each move he makes.\n     * The score of each move is calculated with the Manhattan distance between the source and destination {@link Place}.\n     * <p>\n     * Student can use {@link Player#getScore()} to get the current score of a player before updating.\n     * {@link Player#setScore(int)} can be used to update the score of a player.\n     * <p>\n     * <strong>Attention: do not need to validate move in this method.</strong>\n     *\n     * @param player the player who just makes a move\n     * @param piece  the piece that is just moved\n     * @param move   the move that is just made\n     */\n    public void updateScore(Player player, Piece piece, Move move) {\n        // TODO student implementation\n    }\n\n\n    /**\n     * Make a move.\n     * This method performs moving a {@link Piece} from source to destination {@link Place} according {@link Move} object.\n     * Note that after the move, there will be no {@link Piece} in source {@link Place}.\n     * <p>\n     * Positions of all {@link Piece}s on the gameboard are stored in {@link JesonMor#board} field as a 2-dimension array of\n     * {@link Piece} objects.\n     * The x and y coordinate of a {@link Place} on the gameboard are used as index in {@link JesonMor#board}.\n     * E.g. {@code board[place.x()][place.y()]}.\n     * If one {@link Place} does not have a piece on it, it will be null in {@code board[place.x()][place.y()]}.\n     * Student may modify elements in {@link JesonMor#board} to implement moving a {@link Piece}.\n     * The {@link Move} object can be considered valid on present gameboard.\n     *\n     * @param move the move to make\n     */\n    public void movePiece(Move move) {\n        // TODO student implementation\n    }\n\n    /**\n     * Get all available moves of one player.\n     * This method is called when it is the {@link Player}'s turn to make a move.\n     * It will iterate all {@link Piece}s belonging to the {@link Player} on board and obtain available moves of\n     * each of the {@link Piece}s through method {@link Piece#getAvailableMoves(Game, Place)} of each {@link Piece}.\n     * <p>\n     * <strong>Attention: Student should make sure all {@link Move}s returned are valid.</strong>\n     *\n     * @param player the player whose available moves to get\n     * @return an array of available moves\n     */\n    public Move[] getAvailableMoves(Player player) {\n        // TODO student implementation\n        return new Move[0];\n    }\n}\n```\n", "code_context": "```java\npackage assignment.piece;\n\nimport assignment.piece.FirstNMovesProtectionRule;\nimport assignment.piece.KnightBlockRule;\nimport assignment.piece.KnightMoveRule;\nimport assignment.piece.NilMoveRule;\nimport assignment.piece.OccupiedRule;\nimport assignment.piece.OutOfBoundaryRule;\nimport assignment.piece.Rule;\nimport assignment.piece.VacantRule;\nimport assignment.protocol.Configuration;\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\nimport assignment.protocol.Piece;\nimport assignment.protocol.Place;\nimport assignment.protocol.Player;\n\nimport java.util.*;\nimport java.util.function.IntFunction;\nimport java.util.function.Predicate;\nimport java.util.stream.Stream;\n\n/**\n * Knight piece that moves similar to knight in chess.\n * Rules of move of Knight can be found in wikipedia (https://en.wikipedia.org/wiki/Knight_(chess)).\n *\n * @see <a href='https://en.wikipedia.org/wiki/Knight_(chess)'>Wikipedia</a>\n */\npublic class Knight extends Piece {\n    public Knight(Player player) {\n        super(player);\n    }\n\n    @Override\n    public char getLabel() {\n        return 'K';\n    }\n\n    /**\n     * Returns an array of moves that are valid given the current place of the piece.\n     * Given the {@link Game} object and the {@link Place} that current knight piece locates, this method should\n     * return ALL VALID {@link Move}s according to the current {@link Place} of this knight piece.\n     * All the returned {@link Move} should have source equal to the source parameter.\n     * <p>\n     * Hint: you should consider corner cases when the {@link Move} is not valid on the gameboard.\n     * Several tests are provided and your implementation should pass them.\n     * <p>\n     * <strong>Attention: Student should make sure all {@link Move}s returned are valid.</strong>\n     *\n     * @param game   the game object\n     * @param source the current place of the piece\n     * @return an array of available moves\n     */\n    @Override\n    public Move[] getAvailableMoves(Game game, Place source) {\n        // TODO student implementation\n        return new Move[0];\n    }\n}\n\n```\n\n```java\npackage assignment.protocol;\n\npublic enum Color {\n    DEFAULT(\"\\u001B[0m\"),\n    BLACK(\"\\u001B[30m\"),\n    RED(\"\\u001B[31m\"),\n    GREEN(\"\\u001B[32m\"),\n    YELLOW(\"\\u001B[33m\"),\n    BLUE(\"\\u001B[34m\"),\n    PURPLE(\"\\u001B[35m\"),\n    CYAN(\"\\u001B[36m\"),\n    WHITE(\"\\u001B[37m\");\n\n    private final String ansiColor;\n\n    Color(String ansiColor) {\n        this.ansiColor = ansiColor;\n    }\n\n    public String toString() {\n        return ansiColor;\n    }\n}\n```\n\n```java\npackage assignment.protocol;\n\nimport assignment.protocol.exception.InvalidConfigurationError;\n\n/**\n * Game configuration, including:\n * 1. size of gameboard\n * 2. place (square) of central square in classical Jeson Mor\n * 3. the initial game board with pieces on it, which is configurable through {@link Configuration#addInitialPiece(Piece, Place)}\n * 4. the two players.\n */\npublic class Configuration implements Cloneable {\n    /**\n     * Size of gameboard.\n     * The gameboard has equal size in width and height.\n     * The size should be an odd number.\n     */\n    private final int size;\n\n    /**\n     * An array of two players in the game.\n     * Note that in the implementation of {@link Game#start()} the first player in this array moves first when game\n     * starts.\n     */\n    private Player[] players;\n\n    /**\n     * The initial map of the gameboard, containing initial pieces and their places.\n     * This map has keys for all places in the gameboard, with or without pieces.\n     * If there is no piece in one place, the place is mapped to null.\n     */\n    private Piece[][] initialBoard;\n\n    /**\n     * The central square of the gameboard.\n     */\n    private Place centralPlace;\n\n    /**\n     * This number means: within the first {@code numMovesProtection} number of moves in the game, capturing\n     * {@link Piece}s is not allowed.\n     */\n    private final int numMovesProtection;\n\n    /**\n     * Constructor of configuration\n     *\n     * @param size size of the gameboard.\n     * @param players an array of two players in the game, the first player should move first when game starts.\n     * @param numMovesProtection the first number of moves where capturing pieces is not allowed\n     */\n    public Configuration(int size, Player[] players, int numMovesProtection) {\n        // validate size\n        if (size < 3) {\n            throw new InvalidConfigurationError(\"size of gameboard must be at least 3\");\n        }\n        if (size % 2 != 1) {\n            throw new InvalidConfigurationError(\"size of gameboard must be an odd number\");\n        }\n        if (size > 25) {\n            throw new InvalidConfigurationError(\"size of gameboard is at most 25\");\n        }\n        this.size = size;\n        // We only have 2 players\n        this.players = players;\n        if (players.length != 2) {\n            throw new InvalidConfigurationError(\"there must be exactly two players\");\n        }\n        // initialize map of the game board by putting every place null (meaning no piece)\n        this.initialBoard = new Piece[size][];\n        for (int x = 0; x < size; x++) {\n            this.initialBoard[x] = new Piece[size];\n            for (int y = 0; y < size; y++) {\n                this.initialBoard[x][y] = null;\n            }\n        }\n        // calculate the central place\n        this.centralPlace = new Place(size / 2, size / 2);\n\n        if (numMovesProtection < 0) {\n            throw new InvalidConfigurationError(\"number of moves with capture protection cannot be negative\");\n        }\n        this.numMovesProtection = numMovesProtection;\n    }\n\n    public Configuration(int size, Player[] players) {\n        this(size, players, 0);\n    }\n\n    /**\n     * Add piece to the initial gameboard.\n     * The player that this piece belongs to will be automatically added into the configuration.\n     *\n     * @param piece piece to be added\n     * @param place place to put the piece\n     */\n    public void addInitialPiece(Piece piece, Place place) {\n        if (!piece.getPlayer().equals(this.players[0]) && !piece.getPlayer().equals(this.players[1])) {\n            throw new InvalidConfigurationError(\"the player of the piece is unknown\");\n        }\n        if (place.x() >= this.size || place.y() >= this.size) {\n            // The place must be inside the gameboard\n            throw new InvalidConfigurationError(\"the place\" + place.toString() + \" must be inside the gameboard\");\n        }\n        if (place.equals(this.centralPlace)) {\n            throw new InvalidConfigurationError(\"piece cannot be put at central place initially\");\n        }\n\n        // put the piece on the initial board\n        this.initialBoard[place.x()][place.y()] = piece;\n    }\n\n    public void addInitialPiece(Piece piece, int x, int y) {\n        this.addInitialPiece(piece, new Place(x, y));\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public Player[] getPlayers() {\n        return players;\n    }\n\n    public Piece[][] getInitialBoard() {\n        return initialBoard;\n    }\n\n    public Place getCentralPlace() {\n        return centralPlace;\n    }\n\n    public int getNumMovesProtection() {\n        return numMovesProtection;\n    }\n\n    @Override\n    public Configuration clone() throws CloneNotSupportedException {\n        Configuration cloned = (Configuration) super.clone();\n        cloned.players = this.players.clone();\n        for (int i = 0; i < this.players.length; i++) {\n            cloned.players[i] = this.players[i].clone();\n        }\n        cloned.initialBoard = this.initialBoard.clone();\n        for (int i = 0; i < this.size; i++) {\n            cloned.initialBoard[i] = this.initialBoard[i].clone();\n            // no need to deep copy piece\n            System.arraycopy(this.initialBoard[i], 0, cloned.initialBoard[i], 0, this.size);\n        }\n        cloned.centralPlace = this.centralPlace.clone();\n        return cloned;\n    }\n}\n\n```\n\n```java\npackage assignment.protocol;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\n/**\n * The Game class\n */\npublic abstract class Game implements Cloneable {\n    /**\n     * Game configuration\n     */\n    protected Configuration configuration;\n\n    /**\n     * The gameboard, which is a 2-dimensional array of {@link Piece}, representing all the {@link Place} (squares) on\n     * the board.\n     * If there is a piece in some {@link Place} place(x,y), then {@code board[place.x()][place.y()]} will be the\n     * piece object, otherwise null.\n     * In other words, the board is a 2-D array with length equal to size of the board in both dimensions.\n     */\n    protected Piece[][] board;\n\n    /**\n     * Current player who is supposed to make a move.\n     */\n    protected Player currentPlayer;\n\n    /**\n     * The current number of moves made by two players\n     */\n    protected int numMoves = 0;\n\n    public Game(Configuration configuration) {\n        this.configuration = configuration;\n        this.board = configuration.getInitialBoard();\n    }\n\n    /**\n     * Start the game\n     * Players will take turns according to the order in {@link Configuration#getPlayers()} to make a move until\n     * a player wins.\n     *\n     * @return the winner\n     */\n    public abstract Player start();\n\n    /**\n     * Get the winner of the game. If there is no winner yet, return null;\n     *\n     * @param lastPlayer the last player who makes a move\n     * @param lastPiece the last piece that is moved by the player\n     * @param lastMove   the last move made by lastPlayer\n     * @return the winner if it exists, otherwise return null\n     */\n    public abstract Player getWinner(Player lastPlayer, Piece lastPiece, Move lastMove);\n\n    /**\n     * Update the score of a player according to the piece and corresponding move made by him just now.\n     *\n     * @param player the player who just makes a move\n     * @param piece  the piece that is just moved\n     * @param move   the move that is just made\n     */\n    public abstract void updateScore(Player player, Piece piece, Move move);\n\n    /**\n     * Make a move.\n     *\n     * @param move the move to make\n     */\n    public abstract void movePiece(Move move);\n\n    /**\n     * Get all available moves of one player.\n     *\n     * @param player the player whose available moves to get\n     * @return an array of available moves\n     */\n    public abstract Move[] getAvailableMoves(Player player);\n\n    /**\n     * Refresh the output printed in the console, which shows the following things.\n     * 1. the gameboard and pieces on it\n     * 2. scores of the players\n     * 3. other help information\n     */\n    public void refreshOutput() {\n        int size = this.configuration.getSize();\n        ArrayList<List<String>> contents = new ArrayList<List<String>>();\n        for (int row = size - 1; row >= 0; row--) {\n            ArrayList<String> rowContent = new ArrayList<String>();\n            for (int col = 0; col < size; col++) {\n                Piece piece = this.getPiece(col, row);\n                if (piece == null) {\n                    if (this.getCentralPlace().equals(new Place(col, row))) {\n                        rowContent.add(\"x\");\n                    } else {\n                        rowContent.add(\".\");\n                    }\n                } else {\n                    Player player = piece.getPlayer();\n                    rowContent.add(String.format(\"%s%c%s\",\n                            player.getColor(),\n                            piece.getLabel(),\n                            Color.DEFAULT));\n                }\n            }\n            contents.add(rowContent);\n        }\n        ArrayList<String> xCoordinates = new ArrayList<String>();\n        for (int i = 0; i < size; i++) {\n            xCoordinates.add(String.valueOf((char) ('a' + i)));\n        }\n        Collections.reverse(contents);\n\n        // clear screen\n        System.out.print(\"\\u001b[2J\");\n        System.out.flush();\n\n        System.out.println();\n        System.ou"}
{"task_id": "PA20/Main.java", "target": "assignment/Main.java", "code": "```java\npackage assignment;\n\nimport assignment.JesonMor;\nimport assignment.piece.Archer;\nimport assignment.piece.Knight;\nimport assignment.player.ConsolePlayer;\nimport assignment.player.RandomPlayer;\nimport assignment.protocol.Configuration;\nimport assignment.protocol.Game;\nimport assignment.protocol.Player;\nimport assignment.protocol.Piece;\n\npublic class Main {\n    /**\n     * Create and initialize a game.\n     * Student should first construct a {@link Configuration} object with two players.\n     * Then add initial pieces to gameboard in the {@link Configuration} object.\n     * After that, use this {@link Configuration} object to construct a {@link JesonMor} game object\n     * This method should return the created {@link JesonMor} object.\n     * <p>\n     * The initialized gameboard should comply to the requirements of the assignment.\n     * The user player should be put\n     * first in the player array in the configuration and user player should moves first.\n     *\n     * <strong>Attention: The code in this method is only an example of using {@link Configuration} to initialize\n     * gameboard, Students should remove them and implement on their own.</strong>\n     *\n     * @param size               size of gameboard\n     * @param numMovesProtection number of moves with capture protection\n     * @return the game object\n     */\n    public static Game createGame(int size, int numMovesProtection) {\n        // TODO student implementation\n        // The following lines are example of constructing a game object, you may modify them as you wish.\n        ConsolePlayer userPlayer = new ConsolePlayer(\"UserPlayer\");\n        RandomPlayer computerPlayer = new RandomPlayer(\"ComputerPlayer\");\n        // we give\n        Configuration configuration = new Configuration(size, new Player[]{userPlayer, computerPlayer}, numMovesProtection);\n        Knight knight1 = new Knight(userPlayer);\n        Knight knight2 = new Knight(computerPlayer);\n        // put knight1 at place(0,0) on the gameboard\n        configuration.addInitialPiece(knight1, 0, 0);\n        // put knight2 at place(1,0) on the gameboard\n        configuration.addInitialPiece(knight2, 1, 0);\n        return new JesonMor(configuration);\n    }\n\n    public static void main(String[] args) {\n        // start the game\n        String helper = \"two integer arguments are required specifying size of gameboard and number of moves with capturing protection \";\n        if (args.length < 2) {\n            throw new IllegalArgumentException(helper);\n        }\n        int size;\n        int numMovesProtection;\n        try {\n            size = Integer.parseInt(args[0]);\n        } catch (NumberFormatException e) {\n            throw new IllegalArgumentException(\"the first argument is not a number\");\n        }\n        try {\n            numMovesProtection = Integer.parseInt(args[1]);\n        } catch (NumberFormatException e) {\n            throw new IllegalArgumentException(\"the second argument is not a number\");\n        }\n        createGame(size, numMovesProtection).start();\n    }\n}\n\n```\n", "code_context": "```java\npackage assignment;\n\nimport assignment.piece.Knight;\nimport assignment.protocol.Color;\nimport assignment.protocol.Configuration;\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\nimport assignment.protocol.Piece;\nimport assignment.protocol.Place;\nimport assignment.protocol.Player;\n\nimport java.io.*;\nimport java.util.*;\n\n/**\n * This class extends {@link Game}, implementing the game logic of JesonMor game.\n * Student needs to implement methods in this class to make the game work.\n * Hint: make good use of methods predefined in {@link Game} to get various information to facilitate your work.\n * <p>\n * Several sample tests are provided to test your implementation of each method in the test directory.\n * Please make make sure all tests pass before submitting the assignment.\n */\npublic class JesonMor extends Game {\n    public JesonMor(Configuration configuration) {\n        super(configuration);\n    }\n\n    /**\n     * Start the game\n     * Players will take turns according to the order in {@link Configuration#getPlayers()} to make a move until\n     * a player wins.\n     * <p>\n     * In the implementation, student should implement the loop letting two players take turns to move pieces.\n     * The order of the players should be consistent to the order in {@link Configuration#getPlayers()}.\n     * {@link Player#nextMove(Game, Move[])} should be used to retrieve the player's choice of his next move.\n     * After each move, {@link Game#refreshOutput()} should be called to refresh the gameboard printed in the console.\n     * <p>\n     * When a winner appears, set the local variable {@code winner} so that this method can return the winner.\n     *\n     * @return the winner\n     */\n    @Override\n    public Player start() {\n        // reset all things\n        Player winner = null;\n        this.numMoves = 0;\n        this.board = configuration.getInitialBoard();\n        this.currentPlayer = null;\n        this.refreshOutput();\n        while (true) {\n            // TODO student implementation starts here\n\n            // student implementation ends here\n            if (winner != null) {\n                System.out.println();\n                System.out.println(\"Congratulations! \");\n                System.out.printf(\"Winner: %s%s%s\\n\", winner.getColor(), winner.getName(), Color.DEFAULT);\n                return winner;\n            }\n        }\n    }\n\n    /**\n     * Get the winner of the game. If there is no winner yet, return null;\n     * This method will be called every time after a player makes a move and after\n     * {@link JesonMor#updateScore(Player, Piece, Move)} is called, in order to\n     * check whether any {@link Player} wins.\n     * If this method returns a player (the winner), then the game will exit with the winner.\n     * If this method returns null, next player will be asked to make a move.\n     *\n     * @param lastPlayer the last player who makes a move\n     * @param lastMove   the last move made by lastPlayer\n     * @param lastPiece  the last piece that is moved by the player\n     * @return the winner if it exists, otherwise return null\n     */\n    @Override\n    public Player getWinner(Player lastPlayer, Piece lastPiece, Move lastMove) {\n        // TODO student implementation\n        return null;\n    }\n\n    /**\n     * Update the score of a player according to the {@link Piece} and corresponding move made by him just now.\n     * This method will be called every time after a player makes a move, in order to update the corresponding score\n     * of this player.\n     * <p>\n     * The score of a player is the cumulative score of each move he makes.\n     * The score of each move is calculated with the Manhattan distance between the source and destination {@link Place}.\n     * <p>\n     * Student can use {@link Player#getScore()} to get the current score of a player before updating.\n     * {@link Player#setScore(int)} can be used to update the score of a player.\n     * <p>\n     * <strong>Attention: do not need to validate move in this method.</strong>\n     *\n     * @param player the player who just makes a move\n     * @param piece  the piece that is just moved\n     * @param move   the move that is just made\n     */\n    public void updateScore(Player player, Piece piece, Move move) {\n        // TODO student implementation\n    }\n\n\n    /**\n     * Make a move.\n     * This method performs moving a {@link Piece} from source to destination {@link Place} according {@link Move} object.\n     * Note that after the move, there will be no {@link Piece} in source {@link Place}.\n     * <p>\n     * Positions of all {@link Piece}s on the gameboard are stored in {@link JesonMor#board} field as a 2-dimension array of\n     * {@link Piece} objects.\n     * The x and y coordinate of a {@link Place} on the gameboard are used as index in {@link JesonMor#board}.\n     * E.g. {@code board[place.x()][place.y()]}.\n     * If one {@link Place} does not have a piece on it, it will be null in {@code board[place.x()][place.y()]}.\n     * Student may modify elements in {@link JesonMor#board} to implement moving a {@link Piece}.\n     * The {@link Move} object can be considered valid on present gameboard.\n     *\n     * @param move the move to make\n     */\n    public void movePiece(Move move) {\n        // TODO student implementation\n    }\n\n    /**\n     * Get all available moves of one player.\n     * This method is called when it is the {@link Player}'s turn to make a move.\n     * It will iterate all {@link Piece}s belonging to the {@link Player} on board and obtain available moves of\n     * each of the {@link Piece}s through method {@link Piece#getAvailableMoves(Game, Place)} of each {@link Piece}.\n     * <p>\n     * <strong>Attention: Student should make sure all {@link Move}s returned are valid.</strong>\n     *\n     * @param player the player whose available moves to get\n     * @return an array of available moves\n     */\n    public Move[] getAvailableMoves(Player player) {\n        // TODO student implementation\n        return new Move[0];\n    }\n}\n```\n\n```java\npackage assignment.piece;\n\nimport assignment.piece.ArcherMoveRule;\nimport assignment.piece.FirstNMovesProtectionRule;\nimport assignment.piece.NilMoveRule;\nimport assignment.piece.OccupiedRule;\nimport assignment.piece.OutOfBoundaryRule;\nimport assignment.piece.Rule;\nimport assignment.piece.VacantRule;\nimport assignment.protocol.Configuration;\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\nimport assignment.protocol.Piece;\nimport assignment.protocol.Place;\nimport assignment.protocol.Player;\n\nimport java.util.*;\nimport java.util.function.IntFunction;\nimport java.util.function.Predicate;\nimport java.util.stream.Stream;\n\n/**\n * Archer piece that moves similar to cannon in chinese chess.\n * Rules of move of Archer can be found in wikipedia (https://en.wikipedia.org/wiki/Xiangqi#Cannon).\n * <p>\n * <strong>Attention: If you want to implement Archer as the bonus task, you should remove \"{@code throw new\n * UnsupportedOperationException();}\" in the constructor of this class.</strong>\n *\n * @see <a href='https://en.wikipedia.org/wiki/Xiangqi#Cannon'>Wikipedia</a>\n */\npublic class Archer extends Piece {\n    public Archer(Player player) {\n        super(player);\n        throw new UnsupportedOperationException(); // remove this line if you plan to implement Archer\n    }\n\n    @Override\n    public char getLabel() {\n        return 'A';\n    }\n\n    /**\n     * Returns an array of moves that are valid given the current place of the piece.\n     * Given the {@link Game} object and the {@link Place} that current knight piece locates, this method should\n     * return ALL VALID {@link Move}s according to the current {@link Place} of this knight piece.\n     * All the returned {@link Move} should have source equal to the source parameter.\n     * <p>\n     * Hint: you should consider corner cases when the {@link Move} is not valid on the gameboard.\n     * Several tests are provided and your implementation should pass them.\n     * <p>\n     * <strong>Attention: Student should make sure all {@link Move}s returned are valid.</strong>\n     *\n     * @param game   the game object\n     * @param source the current place of the piece\n     * @return an array of available moves\n     */\n    @Override\n    public Move[] getAvailableMoves(Game game, Place source) {\n        // TODO student implementation\n        return new Move[0];\n    }\n}\n\n```\n\n```java\npackage assignment.piece;\n\nimport assignment.piece.FirstNMovesProtectionRule;\nimport assignment.piece.KnightBlockRule;\nimport assignment.piece.KnightMoveRule;\nimport assignment.piece.NilMoveRule;\nimport assignment.piece.OccupiedRule;\nimport assignment.piece.OutOfBoundaryRule;\nimport assignment.piece.Rule;\nimport assignment.piece.VacantRule;\nimport assignment.protocol.Configuration;\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\nimport assignment.protocol.Piece;\nimport assignment.protocol.Place;\nimport assignment.protocol.Player;\n\nimport java.util.*;\nimport java.util.function.IntFunction;\nimport java.util.function.Predicate;\nimport java.util.stream.Stream;\n\n/**\n * Knight piece that moves similar to knight in chess.\n * Rules of move of Knight can be found in wikipedia (https://en.wikipedia.org/wiki/Knight_(chess)).\n *\n * @see <a href='https://en.wikipedia.org/wiki/Knight_(chess)'>Wikipedia</a>\n */\npublic class Knight extends Piece {\n    public Knight(Player player) {\n        super(player);\n    }\n\n    @Override\n    public char getLabel() {\n        return 'K';\n    }\n\n    /**\n     * Returns an array of moves that are valid given the current place of the piece.\n     * Given the {@link Game} object and the {@link Place} that current knight piece locates, this method should\n     * return ALL VALID {@link Move}s according to the current {@link Place} of this knight piece.\n     * All the returned {@link Move} should have source equal to the source parameter.\n     * <p>\n     * Hint: you should consider corner cases when the {@link Move} is not valid on the gameboard.\n     * Several tests are provided and your implementation should pass them.\n     * <p>\n     * <strong>Attention: Student should make sure all {@link Move}s returned are valid.</strong>\n     *\n     * @param game   the game object\n     * @param source the current place of the piece\n     * @return an array of available moves\n     */\n    @Override\n    public Move[] getAvailableMoves(Game game, Place source) {\n        // TODO student implementation\n        return new Move[0];\n    }\n}\n\n```\n\n```java\npackage assignment.player;\n\nimport assignment.piece.ArcherMoveRule;\nimport assignment.piece.FirstNMovesProtectionRule;\nimport assignment.piece.KnightBlockRule;\nimport assignment.piece.KnightMoveRule;\nimport assignment.piece.NilMoveRule;\nimport assignment.piece.OccupiedRule;\nimport assignment.piece.OutOfBoundaryRule;\nimport assignment.piece.Rule;\nimport assignment.piece.VacantRule;\nimport assignment.protocol.Color;\nimport assignment.protocol.Configuration;\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\nimport assignment.protocol.Piece;\nimport assignment.protocol.Place;\nimport assignment.protocol.Player;\n\nimport java.io.*;\nimport java.util.Scanner;\n\n/**\n * The player that makes move according to user input from console.\n */\npublic class ConsolePlayer extends Player {\n    public ConsolePlayer(String name, Color color) {\n        super(name, color);\n    }\n\n    public ConsolePl"}
{"task_id": "PA20/ArcherMoveRule.java", "target": "assignment/piece/ArcherMoveRule.java", "code": "```java\npackage assignment.piece;\n\nimport assignment.piece.Archer;\nimport assignment.piece.Rule;\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\nimport assignment.protocol.Piece;\nimport assignment.protocol.Place;\nimport assignment.protocol.Player;\n\n/**\n * The rule of moving of Archer, which is similar to the moving rule of cannon in Chinese chess.\n * Cannons move like chariots, any distance orthogonally without jumping, but can only capture by jumping a single piece of either colour along the path of attack.\n */\npublic class ArcherMoveRule implements Rule {\n    @Override\n    public boolean validate(Game game, Move move) {\n        if (!(game.getPiece(move.getSource()) instanceof Archer)) {\n            return true;\n        }\n        // TODO student implementation\n        return false;\n    }\n\n    @Override\n    public String getDescription() {\n        return \"archer move rule is violated\";\n    }\n}\n\n```\n", "code_context": "```java\npackage assignment.piece;\n\nimport assignment.piece.ArcherMoveRule;\nimport assignment.piece.FirstNMovesProtectionRule;\nimport assignment.piece.NilMoveRule;\nimport assignment.piece.OccupiedRule;\nimport assignment.piece.OutOfBoundaryRule;\nimport assignment.piece.Rule;\nimport assignment.piece.VacantRule;\nimport assignment.protocol.Configuration;\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\nimport assignment.protocol.Piece;\nimport assignment.protocol.Place;\nimport assignment.protocol.Player;\n\nimport java.util.*;\nimport java.util.function.IntFunction;\nimport java.util.function.Predicate;\nimport java.util.stream.Stream;\n\n/**\n * Archer piece that moves similar to cannon in chinese chess.\n * Rules of move of Archer can be found in wikipedia (https://en.wikipedia.org/wiki/Xiangqi#Cannon).\n * <p>\n * <strong>Attention: If you want to implement Archer as the bonus task, you should remove \"{@code throw new\n * UnsupportedOperationException();}\" in the constructor of this class.</strong>\n *\n * @see <a href='https://en.wikipedia.org/wiki/Xiangqi#Cannon'>Wikipedia</a>\n */\npublic class Archer extends Piece {\n    public Archer(Player player) {\n        super(player);\n        throw new UnsupportedOperationException(); // remove this line if you plan to implement Archer\n    }\n\n    @Override\n    public char getLabel() {\n        return 'A';\n    }\n\n    /**\n     * Returns an array of moves that are valid given the current place of the piece.\n     * Given the {@link Game} object and the {@link Place} that current knight piece locates, this method should\n     * return ALL VALID {@link Move}s according to the current {@link Place} of this knight piece.\n     * All the returned {@link Move} should have source equal to the source parameter.\n     * <p>\n     * Hint: you should consider corner cases when the {@link Move} is not valid on the gameboard.\n     * Several tests are provided and your implementation should pass them.\n     * <p>\n     * <strong>Attention: Student should make sure all {@link Move}s returned are valid.</strong>\n     *\n     * @param game   the game object\n     * @param source the current place of the piece\n     * @return an array of available moves\n     */\n    @Override\n    public Move[] getAvailableMoves(Game game, Place source) {\n        // TODO student implementation\n        return new Move[0];\n    }\n}\n\n```\n\n```java\npackage assignment.piece;\n\n\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\n\n/**\n * Interface that a rule should implement.\n * Every mode in the gameboard should not violate the rule.\n */\npublic interface Rule {\n    /**\n     * Validate the move. if the rule is violated return false.\n     * <p>\n     * [Hint] the piece that is to be moved can be obtained using {@code game.getPiece(move.getSource()}.\n     *\n     * @param game the current game object\n     * @param move the move to be validated\n     * @return true if the rule check pass. If the rule is violated, return false.\n     */\n    public boolean validate(Game game, Move move);\n\n    /**\n     * Returns a string description of the rule, which will be printed as error message when the rule is violated.\n     *\n     * @return description of the rule\n     */\n    public String getDescription();\n}\n\n// Below are several predefined global rules for all moves.\n\n\n```\n\n```java\npackage assignment.protocol;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\n/**\n * The Game class\n */\npublic abstract class Game implements Cloneable {\n    /**\n     * Game configuration\n     */\n    protected Configuration configuration;\n\n    /**\n     * The gameboard, which is a 2-dimensional array of {@link Piece}, representing all the {@link Place} (squares) on\n     * the board.\n     * If there is a piece in some {@link Place} place(x,y), then {@code board[place.x()][place.y()]} will be the\n     * piece object, otherwise null.\n     * In other words, the board is a 2-D array with length equal to size of the board in both dimensions.\n     */\n    protected Piece[][] board;\n\n    /**\n     * Current player who is supposed to make a move.\n     */\n    protected Player currentPlayer;\n\n    /**\n     * The current number of moves made by two players\n     */\n    protected int numMoves = 0;\n\n    public Game(Configuration configuration) {\n        this.configuration = configuration;\n        this.board = configuration.getInitialBoard();\n    }\n\n    /**\n     * Start the game\n     * Players will take turns according to the order in {@link Configuration#getPlayers()} to make a move until\n     * a player wins.\n     *\n     * @return the winner\n     */\n    public abstract Player start();\n\n    /**\n     * Get the winner of the game. If there is no winner yet, return null;\n     *\n     * @param lastPlayer the last player who makes a move\n     * @param lastPiece the last piece that is moved by the player\n     * @param lastMove   the last move made by lastPlayer\n     * @return the winner if it exists, otherwise return null\n     */\n    public abstract Player getWinner(Player lastPlayer, Piece lastPiece, Move lastMove);\n\n    /**\n     * Update the score of a player according to the piece and corresponding move made by him just now.\n     *\n     * @param player the player who just makes a move\n     * @param piece  the piece that is just moved\n     * @param move   the move that is just made\n     */\n    public abstract void updateScore(Player player, Piece piece, Move move);\n\n    /**\n     * Make a move.\n     *\n     * @param move the move to make\n     */\n    public abstract void movePiece(Move move);\n\n    /**\n     * Get all available moves of one player.\n     *\n     * @param player the player whose available moves to get\n     * @return an array of available moves\n     */\n    public abstract Move[] getAvailableMoves(Player player);\n\n    /**\n     * Refresh the output printed in the console, which shows the following things.\n     * 1. the gameboard and pieces on it\n     * 2. scores of the players\n     * 3. other help information\n     */\n    public void refreshOutput() {\n        int size = this.configuration.getSize();\n        ArrayList<List<String>> contents = new ArrayList<List<String>>();\n        for (int row = size - 1; row >= 0; row--) {\n            ArrayList<String> rowContent = new ArrayList<String>();\n            for (int col = 0; col < size; col++) {\n                Piece piece = this.getPiece(col, row);\n                if (piece == null) {\n                    if (this.getCentralPlace().equals(new Place(col, row))) {\n                        rowContent.add(\"x\");\n                    } else {\n                        rowContent.add(\".\");\n                    }\n                } else {\n                    Player player = piece.getPlayer();\n                    rowContent.add(String.format(\"%s%c%s\",\n                            player.getColor(),\n                            piece.getLabel(),\n                            Color.DEFAULT));\n                }\n            }\n            contents.add(rowContent);\n        }\n        ArrayList<String> xCoordinates = new ArrayList<String>();\n        for (int i = 0; i < size; i++) {\n            xCoordinates.add(String.valueOf((char) ('a' + i)));\n        }\n        Collections.reverse(contents);\n\n        // clear screen\n        System.out.print(\"\\u001b[2J\");\n        System.out.flush();\n\n        System.out.println();\n        System.out.println(\"### COMP3021 Programming Assignment 1 ###\");\n        System.out.println();\n        System.out.println(\"Guide: to move a piece, input the coordinate of source and the destination.\");\n        System.out.println(\"For example: a1->b2 means to move the piece at 'a1' to 'b2'\");\n        if (this.numMoves < this.configuration.getNumMovesProtection()) {\n            System.out.println();\n            System.out.println(\"Notice: first \" + this.configuration.getNumMovesProtection() + \" moves are not allowed to\" +\n                    \" capture pieces or win the game.\");\n        }\n        System.out.println();\n        System.out.println(\"Total Moves: \" + this.numMoves);\n        // print scores of players\n        for (Player player :\n                this.configuration.getPlayers()) {\n            System.out.printf(\"%s%s%s score: %d\\n\", player.getColor(), player.getName(), Color.DEFAULT,\n                    player.getScore());\n        }\n        System.out.println();\n        // print the gameboard\n        int leftPadding = 8;\n        StringBuilder paddingSpaceBuilder = new StringBuilder();\n        paddingSpaceBuilder.append(\" \".repeat(leftPadding));\n        System.out.printf(\"%s%s\\n\",\n                paddingSpaceBuilder.toString(),\n                xCoordinates.parallelStream()\n                        .collect(Collectors.joining(\" \")));\n        StringBuilder borderBuilder = new StringBuilder();\n        borderBuilder.append(\"-\".repeat(Math.max(0, contents.get(0).size() * 2 - 1)));\n        System.out.printf(\"%s%s\\n\",\n                paddingSpaceBuilder.toString(),\n                borderBuilder.toString());\n        for (int row = contents.size() - 1; row >= 0; row--) {\n            System.out.printf(\"%\" + (leftPadding - 1) + \"d|%s|%d\\n\",\n                    row + 1,\n                    contents.get(row).parallelStream().map(Object::toString).collect(Collectors.joining(\" \")),\n                    row + 1);\n        }\n        System.out.printf(\"%s%s\\n\",\n                paddingSpaceBuilder.toString(),\n                borderBuilder.toString());\n        System.out.printf(\"%s%s\\n\",\n                paddingSpaceBuilder.toString(),\n                xCoordinates.parallelStream()\n                        .collect(Collectors.joining(\" \")));\n        System.out.println();\n    }\n\n    /**\n     * Get the piece in the place\n     *\n     * @param place the place of the piece\n     * @return the piece\n     */\n    public Piece getPiece(Place place) {\n        return this.board[place.x()][place.y()];\n    }\n\n    public Piece getPiece(int x, int y) {\n        return this.getPiece(new Place(x, y));\n    }\n\n    public Player getCurrentPlayer() {\n        return currentPlayer != null ? currentPlayer : this.configuration.getPlayers()[0];\n    }\n\n    public Player[] getPlayers() {\n        return configuration.getPlayers();\n    }\n\n    public int getNumMoves() {\n        return numMoves;\n    }\n\n    public Configuration getConfiguration() {\n        return configuration;\n    }\n\n    public Place getCentralPlace() {\n        return configuration.getCentralPlace();\n    }\n\n    @Override\n    public Game clone() throws CloneNotSupportedException {\n        Game cloned = (Game) super.clone();\n        cloned.configuration = this.configuration.clone();\n        cloned.board = this.board.clone();\n        for (int i = 0; i < this.configuration.getSize(); i++) {\n            cloned.board[i] = this.board[i].clone();\n            // no need to deep copy pieces\n            if (this.configuration.getSize() >= 0)\n                System.arraycopy(this.board[i], 0, cloned.board[i], 0, this.configuration.getSize());\n        }\n        cloned.currentPlayer = currentPlayer == null ? null : currentPlayer.clone();\n        return cloned;\n    }\n}\n```\n\n```java\npackage assignment.protocol;\n\nimport java.util.Objects;\nimport java.util.StringJoiner;\n\n/**\n * Move class represent a move made by a {@link Player}, moving a piece from one {@link Place} to another {@link Place}.\n */\npublic class Move implements Cloneable {\n    /**\n     * Source place of the move.\n     */\n    private Place source;\n\n    /**\n     * Move destination\n     */\n    private Place destination;\n\n    public Move(Place source, Place destination) {\n        this.source = source;\n        this.destination = destination;\n    }\n\n    public Move(int sourceX, int sourceY, int destinationX, int destinationY) {\n        this(new Place(sourceX, sourceY), new Place(destinationX, destinationY));\n    }\n\n    public Move(Place source, int destinationX, int destinationY) {\n        this(source, new Place(destinationX, destinationY));\n    }\n\n    /* Getters start */\n    public Place getSource() {\n        return s"}
{"task_id": "PA20/FirstNMovesProtectionRule.java", "target": "assignment/piece/FirstNMovesProtectionRule.java", "code": "```java\npackage assignment.piece;\n\nimport assignment.piece.Rule;\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\nimport assignment.protocol.Piece;\nimport assignment.protocol.Place;\n\n/**\n * The rule that requires capturing piece is not allowed within the first certain number of moves.\n */\npublic class FirstNMovesProtectionRule implements Rule {\n    /**\n     * The number of moves within which capturing piece is not allowed.\n     */\n    private final int numProtectedMoves;\n\n    public FirstNMovesProtectionRule(int numProtectedMoves) {\n        this.numProtectedMoves = numProtectedMoves;\n    }\n\n    @Override\n    public boolean validate(Game game, Move move) {\n        // TODO\n        return false;\n    }\n\n    @Override\n    public String getDescription() {\n        return \"Capturing piece in the first \" + this.numProtectedMoves + \" moves are not allowed\";\n    }\n}\n\n```\n", "code_context": "```java\npackage assignment.piece;\n\n\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\n\n/**\n * Interface that a rule should implement.\n * Every mode in the gameboard should not violate the rule.\n */\npublic interface Rule {\n    /**\n     * Validate the move. if the rule is violated return false.\n     * <p>\n     * [Hint] the piece that is to be moved can be obtained using {@code game.getPiece(move.getSource()}.\n     *\n     * @param game the current game object\n     * @param move the move to be validated\n     * @return true if the rule check pass. If the rule is violated, return false.\n     */\n    public boolean validate(Game game, Move move);\n\n    /**\n     * Returns a string description of the rule, which will be printed as error message when the rule is violated.\n     *\n     * @return description of the rule\n     */\n    public String getDescription();\n}\n\n// Below are several predefined global rules for all moves.\n\n\n```\n\n```java\npackage assignment.protocol;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\n/**\n * The Game class\n */\npublic abstract class Game implements Cloneable {\n    /**\n     * Game configuration\n     */\n    protected Configuration configuration;\n\n    /**\n     * The gameboard, which is a 2-dimensional array of {@link Piece}, representing all the {@link Place} (squares) on\n     * the board.\n     * If there is a piece in some {@link Place} place(x,y), then {@code board[place.x()][place.y()]} will be the\n     * piece object, otherwise null.\n     * In other words, the board is a 2-D array with length equal to size of the board in both dimensions.\n     */\n    protected Piece[][] board;\n\n    /**\n     * Current player who is supposed to make a move.\n     */\n    protected Player currentPlayer;\n\n    /**\n     * The current number of moves made by two players\n     */\n    protected int numMoves = 0;\n\n    public Game(Configuration configuration) {\n        this.configuration = configuration;\n        this.board = configuration.getInitialBoard();\n    }\n\n    /**\n     * Start the game\n     * Players will take turns according to the order in {@link Configuration#getPlayers()} to make a move until\n     * a player wins.\n     *\n     * @return the winner\n     */\n    public abstract Player start();\n\n    /**\n     * Get the winner of the game. If there is no winner yet, return null;\n     *\n     * @param lastPlayer the last player who makes a move\n     * @param lastPiece the last piece that is moved by the player\n     * @param lastMove   the last move made by lastPlayer\n     * @return the winner if it exists, otherwise return null\n     */\n    public abstract Player getWinner(Player lastPlayer, Piece lastPiece, Move lastMove);\n\n    /**\n     * Update the score of a player according to the piece and corresponding move made by him just now.\n     *\n     * @param player the player who just makes a move\n     * @param piece  the piece that is just moved\n     * @param move   the move that is just made\n     */\n    public abstract void updateScore(Player player, Piece piece, Move move);\n\n    /**\n     * Make a move.\n     *\n     * @param move the move to make\n     */\n    public abstract void movePiece(Move move);\n\n    /**\n     * Get all available moves of one player.\n     *\n     * @param player the player whose available moves to get\n     * @return an array of available moves\n     */\n    public abstract Move[] getAvailableMoves(Player player);\n\n    /**\n     * Refresh the output printed in the console, which shows the following things.\n     * 1. the gameboard and pieces on it\n     * 2. scores of the players\n     * 3. other help information\n     */\n    public void refreshOutput() {\n        int size = this.configuration.getSize();\n        ArrayList<List<String>> contents = new ArrayList<List<String>>();\n        for (int row = size - 1; row >= 0; row--) {\n            ArrayList<String> rowContent = new ArrayList<String>();\n            for (int col = 0; col < size; col++) {\n                Piece piece = this.getPiece(col, row);\n                if (piece == null) {\n                    if (this.getCentralPlace().equals(new Place(col, row))) {\n                        rowContent.add(\"x\");\n                    } else {\n                        rowContent.add(\".\");\n                    }\n                } else {\n                    Player player = piece.getPlayer();\n                    rowContent.add(String.format(\"%s%c%s\",\n                            player.getColor(),\n                            piece.getLabel(),\n                            Color.DEFAULT));\n                }\n            }\n            contents.add(rowContent);\n        }\n        ArrayList<String> xCoordinates = new ArrayList<String>();\n        for (int i = 0; i < size; i++) {\n            xCoordinates.add(String.valueOf((char) ('a' + i)));\n        }\n        Collections.reverse(contents);\n\n        // clear screen\n        System.out.print(\"\\u001b[2J\");\n        System.out.flush();\n\n        System.out.println();\n        System.out.println(\"### COMP3021 Programming Assignment 1 ###\");\n        System.out.println();\n        System.out.println(\"Guide: to move a piece, input the coordinate of source and the destination.\");\n        System.out.println(\"For example: a1->b2 means to move the piece at 'a1' to 'b2'\");\n        if (this.numMoves < this.configuration.getNumMovesProtection()) {\n            System.out.println();\n            System.out.println(\"Notice: first \" + this.configuration.getNumMovesProtection() + \" moves are not allowed to\" +\n                    \" capture pieces or win the game.\");\n        }\n        System.out.println();\n        System.out.println(\"Total Moves: \" + this.numMoves);\n        // print scores of players\n        for (Player player :\n                this.configuration.getPlayers()) {\n            System.out.printf(\"%s%s%s score: %d\\n\", player.getColor(), player.getName(), Color.DEFAULT,\n                    player.getScore());\n        }\n        System.out.println();\n        // print the gameboard\n        int leftPadding = 8;\n        StringBuilder paddingSpaceBuilder = new StringBuilder();\n        paddingSpaceBuilder.append(\" \".repeat(leftPadding));\n        System.out.printf(\"%s%s\\n\",\n                paddingSpaceBuilder.toString(),\n                xCoordinates.parallelStream()\n                        .collect(Collectors.joining(\" \")));\n        StringBuilder borderBuilder = new StringBuilder();\n        borderBuilder.append(\"-\".repeat(Math.max(0, contents.get(0).size() * 2 - 1)));\n        System.out.printf(\"%s%s\\n\",\n                paddingSpaceBuilder.toString(),\n                borderBuilder.toString());\n        for (int row = contents.size() - 1; row >= 0; row--) {\n            System.out.printf(\"%\" + (leftPadding - 1) + \"d|%s|%d\\n\",\n                    row + 1,\n                    contents.get(row).parallelStream().map(Object::toString).collect(Collectors.joining(\" \")),\n                    row + 1);\n        }\n        System.out.printf(\"%s%s\\n\",\n                paddingSpaceBuilder.toString(),\n                borderBuilder.toString());\n        System.out.printf(\"%s%s\\n\",\n                paddingSpaceBuilder.toString(),\n                xCoordinates.parallelStream()\n                        .collect(Collectors.joining(\" \")));\n        System.out.println();\n    }\n\n    /**\n     * Get the piece in the place\n     *\n     * @param place the place of the piece\n     * @return the piece\n     */\n    public Piece getPiece(Place place) {\n        return this.board[place.x()][place.y()];\n    }\n\n    public Piece getPiece(int x, int y) {\n        return this.getPiece(new Place(x, y));\n    }\n\n    public Player getCurrentPlayer() {\n        return currentPlayer != null ? currentPlayer : this.configuration.getPlayers()[0];\n    }\n\n    public Player[] getPlayers() {\n        return configuration.getPlayers();\n    }\n\n    public int getNumMoves() {\n        return numMoves;\n    }\n\n    public Configuration getConfiguration() {\n        return configuration;\n    }\n\n    public Place getCentralPlace() {\n        return configuration.getCentralPlace();\n    }\n\n    @Override\n    public Game clone() throws CloneNotSupportedException {\n        Game cloned = (Game) super.clone();\n        cloned.configuration = this.configuration.clone();\n        cloned.board = this.board.clone();\n        for (int i = 0; i < this.configuration.getSize(); i++) {\n            cloned.board[i] = this.board[i].clone();\n            // no need to deep copy pieces\n            if (this.configuration.getSize() >= 0)\n                System.arraycopy(this.board[i], 0, cloned.board[i], 0, this.configuration.getSize());\n        }\n        cloned.currentPlayer = currentPlayer == null ? null : currentPlayer.clone();\n        return cloned;\n    }\n}\n```\n\n```java\npackage assignment.protocol;\n\nimport java.util.Objects;\nimport java.util.StringJoiner;\n\n/**\n * Move class represent a move made by a {@link Player}, moving a piece from one {@link Place} to another {@link Place}.\n */\npublic class Move implements Cloneable {\n    /**\n     * Source place of the move.\n     */\n    private Place source;\n\n    /**\n     * Move destination\n     */\n    private Place destination;\n\n    public Move(Place source, Place destination) {\n        this.source = source;\n        this.destination = destination;\n    }\n\n    public Move(int sourceX, int sourceY, int destinationX, int destinationY) {\n        this(new Place(sourceX, sourceY), new Place(destinationX, destinationY));\n    }\n\n    public Move(Place source, int destinationX, int destinationY) {\n        this(source, new Place(destinationX, destinationY));\n    }\n\n    /* Getters start */\n    public Place getSource() {\n        return source;\n    }\n\n    public Place getDestination() {\n        return destination;\n    }\n    /* Getters end */\n\n    /* Object methods start */\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Move move = (Move) o;\n        return source.equals(move.source) &&\n                destination.equals(move.destination);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(source, destination);\n    }\n\n    @Override\n    public String toString() {\n        return new StringJoiner(\", \", Move.class.getSimpleName() + \"[\", \"]\")\n                .add(\"source=\" + source)\n                .add(\"destination=\" + destination)\n                .toString();\n    }\n\n    @Override\n    public Move clone() throws CloneNotSupportedException {\n        Move cloned = (Move) super.clone();\n        cloned.source = this.source.clone();\n        cloned.destination = this.destination.clone();\n        return cloned;\n    }\n\n    /* Object methods end */\n\n}\n\n```\n\n```java\npackage assignment.protocol;\n\n\n/**\n * The abstract class that a game piece should extend.\n */\npublic abstract class Piece {\n    /**\n     * The player that owns this piece.\n     */\n    private final Player player;\n\n    public Piece(Player player) {\n        this.player = player;\n    }\n\n    public final Player getPlayer() {\n        return this.player;\n    }\n\n    /**\n     * Returns a char which is used to facilitate output in the console\n     *\n     * @return the label to represent the piece on the board\n     */\n    public abstract char getLabel();\n\n    /**\n     * Returns an array of moves that are valid given the current place of the piece.\n     *\n     * @param game   the game object\n     * @param source the current place of the piece\n     * @return a set of available moves\n     */\n    public abstract Move[] getAvailableMoves(Game game, Place source);\n}\n\n```\n\n```java\npackage assignment.protocol;\n\n/**\n * A square (position, place) in the gameboard.\n * Represented by coordinates a 2-D coordinate system.\n * <p>\n * x and y coordinates of a place on gameboard are two fields of this class.\n */\npublic class Place implements Cloneable {\n    private int x;\n\n    private int y;\n\n    public Place(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public int x() {\n        return x;\n    }\n\n    public void x(int x) {\n        this.x = x;\n    }\n\n    public int y() {\n        return y;\n    }\n\n    public void y(int y) {\n        this.y = y;\n    }\n\n    @Override\n    publi"}
{"task_id": "PA20/KnightBlockRule.java", "target": "assignment/piece/KnightBlockRule.java", "code": "```java\npackage assignment.piece;\n\nimport assignment.piece.Knight;\nimport assignment.piece.Rule;\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\nimport assignment.protocol.Piece;\nimport assignment.protocol.Place;\n\n/**\n * The blocking rule applying on Knights. The rule is similar to the blocking rule for horse in Chinese chess.\n * The horse does not jump as the knight does in Western chess, and can be blocked by a piece of either colour located one point horizontally or vertically adjacent to it\n */\npublic class KnightBlockRule implements Rule {\n    @Override\n    public boolean validate(Game game, Move move) {\n        if (!(game.getPiece(move.getSource()) instanceof Knight)) {\n            return true;\n        }\n        // TODO student implementation\n        return false;\n    }\n\n    @Override\n    public String getDescription() {\n        return \"knight is blocked by another piece\";\n    }\n}\n\n```\n", "code_context": "```java\npackage assignment.piece;\n\nimport assignment.piece.FirstNMovesProtectionRule;\nimport assignment.piece.KnightBlockRule;\nimport assignment.piece.KnightMoveRule;\nimport assignment.piece.NilMoveRule;\nimport assignment.piece.OccupiedRule;\nimport assignment.piece.OutOfBoundaryRule;\nimport assignment.piece.Rule;\nimport assignment.piece.VacantRule;\nimport assignment.protocol.Configuration;\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\nimport assignment.protocol.Piece;\nimport assignment.protocol.Place;\nimport assignment.protocol.Player;\n\nimport java.util.*;\nimport java.util.function.IntFunction;\nimport java.util.function.Predicate;\nimport java.util.stream.Stream;\n\n/**\n * Knight piece that moves similar to knight in chess.\n * Rules of move of Knight can be found in wikipedia (https://en.wikipedia.org/wiki/Knight_(chess)).\n *\n * @see <a href='https://en.wikipedia.org/wiki/Knight_(chess)'>Wikipedia</a>\n */\npublic class Knight extends Piece {\n    public Knight(Player player) {\n        super(player);\n    }\n\n    @Override\n    public char getLabel() {\n        return 'K';\n    }\n\n    /**\n     * Returns an array of moves that are valid given the current place of the piece.\n     * Given the {@link Game} object and the {@link Place} that current knight piece locates, this method should\n     * return ALL VALID {@link Move}s according to the current {@link Place} of this knight piece.\n     * All the returned {@link Move} should have source equal to the source parameter.\n     * <p>\n     * Hint: you should consider corner cases when the {@link Move} is not valid on the gameboard.\n     * Several tests are provided and your implementation should pass them.\n     * <p>\n     * <strong>Attention: Student should make sure all {@link Move}s returned are valid.</strong>\n     *\n     * @param game   the game object\n     * @param source the current place of the piece\n     * @return an array of available moves\n     */\n    @Override\n    public Move[] getAvailableMoves(Game game, Place source) {\n        // TODO student implementation\n        return new Move[0];\n    }\n}\n\n```\n\n```java\npackage assignment.piece;\n\n\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\n\n/**\n * Interface that a rule should implement.\n * Every mode in the gameboard should not violate the rule.\n */\npublic interface Rule {\n    /**\n     * Validate the move. if the rule is violated return false.\n     * <p>\n     * [Hint] the piece that is to be moved can be obtained using {@code game.getPiece(move.getSource()}.\n     *\n     * @param game the current game object\n     * @param move the move to be validated\n     * @return true if the rule check pass. If the rule is violated, return false.\n     */\n    public boolean validate(Game game, Move move);\n\n    /**\n     * Returns a string description of the rule, which will be printed as error message when the rule is violated.\n     *\n     * @return description of the rule\n     */\n    public String getDescription();\n}\n\n// Below are several predefined global rules for all moves.\n\n\n```\n\n```java\npackage assignment.protocol;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\n/**\n * The Game class\n */\npublic abstract class Game implements Cloneable {\n    /**\n     * Game configuration\n     */\n    protected Configuration configuration;\n\n    /**\n     * The gameboard, which is a 2-dimensional array of {@link Piece}, representing all the {@link Place} (squares) on\n     * the board.\n     * If there is a piece in some {@link Place} place(x,y), then {@code board[place.x()][place.y()]} will be the\n     * piece object, otherwise null.\n     * In other words, the board is a 2-D array with length equal to size of the board in both dimensions.\n     */\n    protected Piece[][] board;\n\n    /**\n     * Current player who is supposed to make a move.\n     */\n    protected Player currentPlayer;\n\n    /**\n     * The current number of moves made by two players\n     */\n    protected int numMoves = 0;\n\n    public Game(Configuration configuration) {\n        this.configuration = configuration;\n        this.board = configuration.getInitialBoard();\n    }\n\n    /**\n     * Start the game\n     * Players will take turns according to the order in {@link Configuration#getPlayers()} to make a move until\n     * a player wins.\n     *\n     * @return the winner\n     */\n    public abstract Player start();\n\n    /**\n     * Get the winner of the game. If there is no winner yet, return null;\n     *\n     * @param lastPlayer the last player who makes a move\n     * @param lastPiece the last piece that is moved by the player\n     * @param lastMove   the last move made by lastPlayer\n     * @return the winner if it exists, otherwise return null\n     */\n    public abstract Player getWinner(Player lastPlayer, Piece lastPiece, Move lastMove);\n\n    /**\n     * Update the score of a player according to the piece and corresponding move made by him just now.\n     *\n     * @param player the player who just makes a move\n     * @param piece  the piece that is just moved\n     * @param move   the move that is just made\n     */\n    public abstract void updateScore(Player player, Piece piece, Move move);\n\n    /**\n     * Make a move.\n     *\n     * @param move the move to make\n     */\n    public abstract void movePiece(Move move);\n\n    /**\n     * Get all available moves of one player.\n     *\n     * @param player the player whose available moves to get\n     * @return an array of available moves\n     */\n    public abstract Move[] getAvailableMoves(Player player);\n\n    /**\n     * Refresh the output printed in the console, which shows the following things.\n     * 1. the gameboard and pieces on it\n     * 2. scores of the players\n     * 3. other help information\n     */\n    public void refreshOutput() {\n        int size = this.configuration.getSize();\n        ArrayList<List<String>> contents = new ArrayList<List<String>>();\n        for (int row = size - 1; row >= 0; row--) {\n            ArrayList<String> rowContent = new ArrayList<String>();\n            for (int col = 0; col < size; col++) {\n                Piece piece = this.getPiece(col, row);\n                if (piece == null) {\n                    if (this.getCentralPlace().equals(new Place(col, row))) {\n                        rowContent.add(\"x\");\n                    } else {\n                        rowContent.add(\".\");\n                    }\n                } else {\n                    Player player = piece.getPlayer();\n                    rowContent.add(String.format(\"%s%c%s\",\n                            player.getColor(),\n                            piece.getLabel(),\n                            Color.DEFAULT));\n                }\n            }\n            contents.add(rowContent);\n        }\n        ArrayList<String> xCoordinates = new ArrayList<String>();\n        for (int i = 0; i < size; i++) {\n            xCoordinates.add(String.valueOf((char) ('a' + i)));\n        }\n        Collections.reverse(contents);\n\n        // clear screen\n        System.out.print(\"\\u001b[2J\");\n        System.out.flush();\n\n        System.out.println();\n        System.out.println(\"### COMP3021 Programming Assignment 1 ###\");\n        System.out.println();\n        System.out.println(\"Guide: to move a piece, input the coordinate of source and the destination.\");\n        System.out.println(\"For example: a1->b2 means to move the piece at 'a1' to 'b2'\");\n        if (this.numMoves < this.configuration.getNumMovesProtection()) {\n            System.out.println();\n            System.out.println(\"Notice: first \" + this.configuration.getNumMovesProtection() + \" moves are not allowed to\" +\n                    \" capture pieces or win the game.\");\n        }\n        System.out.println();\n        System.out.println(\"Total Moves: \" + this.numMoves);\n        // print scores of players\n        for (Player player :\n                this.configuration.getPlayers()) {\n            System.out.printf(\"%s%s%s score: %d\\n\", player.getColor(), player.getName(), Color.DEFAULT,\n                    player.getScore());\n        }\n        System.out.println();\n        // print the gameboard\n        int leftPadding = 8;\n        StringBuilder paddingSpaceBuilder = new StringBuilder();\n        paddingSpaceBuilder.append(\" \".repeat(leftPadding));\n        System.out.printf(\"%s%s\\n\",\n                paddingSpaceBuilder.toString(),\n                xCoordinates.parallelStream()\n                        .collect(Collectors.joining(\" \")));\n        StringBuilder borderBuilder = new StringBuilder();\n        borderBuilder.append(\"-\".repeat(Math.max(0, contents.get(0).size() * 2 - 1)));\n        System.out.printf(\"%s%s\\n\",\n                paddingSpaceBuilder.toString(),\n                borderBuilder.toString());\n        for (int row = contents.size() - 1; row >= 0; row--) {\n            System.out.printf(\"%\" + (leftPadding - 1) + \"d|%s|%d\\n\",\n                    row + 1,\n                    contents.get(row).parallelStream().map(Object::toString).collect(Collectors.joining(\" \")),\n                    row + 1);\n        }\n        System.out.printf(\"%s%s\\n\",\n                paddingSpaceBuilder.toString(),\n                borderBuilder.toString());\n        System.out.printf(\"%s%s\\n\",\n                paddingSpaceBuilder.toString(),\n                xCoordinates.parallelStream()\n                        .collect(Collectors.joining(\" \")));\n        System.out.println();\n    }\n\n    /**\n     * Get the piece in the place\n     *\n     * @param place the place of the piece\n     * @return the piece\n     */\n    public Piece getPiece(Place place) {\n        return this.board[place.x()][place.y()];\n    }\n\n    public Piece getPiece(int x, int y) {\n        return this.getPiece(new Place(x, y));\n    }\n\n    public Player getCurrentPlayer() {\n        return currentPlayer != null ? currentPlayer : this.configuration.getPlayers()[0];\n    }\n\n    public Player[] getPlayers() {\n        return configuration.getPlayers();\n    }\n\n    public int getNumMoves() {\n        return numMoves;\n    }\n\n    public Configuration getConfiguration() {\n        return configuration;\n    }\n\n    public Place getCentralPlace() {\n        return configuration.getCentralPlace();\n    }\n\n    @Override\n    public Game clone() throws CloneNotSupportedException {\n        Game cloned = (Game) super.clone();\n        cloned.configuration = this.configuration.clone();\n        cloned.board = this.board.clone();\n        for (int i = 0; i < this.configuration.getSize(); i++) {\n            cloned.board[i] = this.board[i].clone();\n            // no need to deep copy pieces\n            if (this.configuration.getSize() >= 0)\n                System.arraycopy(this.board[i], 0, cloned.board[i], 0, this.configuration.getSize());\n        }\n        cloned.currentPlayer = currentPlayer == null ? null : currentPlayer.clone();\n        return cloned;\n    }\n}\n```\n\n```java\npackage assignment.protocol;\n\nimport java.util.Objects;\nimport java.util.StringJoiner;\n\n/**\n * Move class represent a move made by a {@link Player}, moving a piece from one {@link Place} to another {@link Place}.\n */\npublic class Move implements Cloneable {\n    /**\n     * Source place of the move.\n     */\n    private Place source;\n\n    /**\n     * Move destination\n     */\n    private Place destination;\n\n    public Move(Place source, Place destination) {\n        this.source = source;\n        this.destination = destination;\n    }\n\n    public Move(int sourceX, int sourceY, int destinationX, int destinationY) {\n        this(new Place(sourceX, sourceY), new Place(destinationX, destinationY));\n    }\n\n    public Move(Place source, int destinationX, int destinationY) {\n        this(source, new Place(destinationX, destinationY));\n    }\n\n    /* Getters start */\n    public Place getSource() {\n        return source;\n    }\n\n    public Place getDestination() {\n        return destination;\n    }\n    /* Getters end */\n\n    /* Object methods start */\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || "}
{"task_id": "PA20/KnightMoveRule.java", "target": "assignment/piece/KnightMoveRule.java", "code": "```java\npackage assignment.piece;\n\nimport assignment.piece.Knight;\nimport assignment.piece.Rule;\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\nimport assignment.protocol.Piece;\nimport assignment.protocol.Place;\n\n/**\n * Moving rule of Knight in chess (no block)\n * It moves two squares vertically and one square horizontally, or two squares horizontally and one square vertically\n */\npublic class KnightMoveRule implements Rule {\n\n    @Override\n    public boolean validate(Game game, Move move) {\n        if (!(game.getPiece(move.getSource()) instanceof Knight)) {\n            return true;\n        }\n        // TODO student implementation\n        return false;\n    }\n\n    @Override\n    public String getDescription() {\n        return \"knight move rule is violated\";\n    }\n}\n\n```\n", "code_context": "```java\npackage assignment.piece;\n\nimport assignment.piece.FirstNMovesProtectionRule;\nimport assignment.piece.KnightBlockRule;\nimport assignment.piece.KnightMoveRule;\nimport assignment.piece.NilMoveRule;\nimport assignment.piece.OccupiedRule;\nimport assignment.piece.OutOfBoundaryRule;\nimport assignment.piece.Rule;\nimport assignment.piece.VacantRule;\nimport assignment.protocol.Configuration;\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\nimport assignment.protocol.Piece;\nimport assignment.protocol.Place;\nimport assignment.protocol.Player;\n\nimport java.util.*;\nimport java.util.function.IntFunction;\nimport java.util.function.Predicate;\nimport java.util.stream.Stream;\n\n/**\n * Knight piece that moves similar to knight in chess.\n * Rules of move of Knight can be found in wikipedia (https://en.wikipedia.org/wiki/Knight_(chess)).\n *\n * @see <a href='https://en.wikipedia.org/wiki/Knight_(chess)'>Wikipedia</a>\n */\npublic class Knight extends Piece {\n    public Knight(Player player) {\n        super(player);\n    }\n\n    @Override\n    public char getLabel() {\n        return 'K';\n    }\n\n    /**\n     * Returns an array of moves that are valid given the current place of the piece.\n     * Given the {@link Game} object and the {@link Place} that current knight piece locates, this method should\n     * return ALL VALID {@link Move}s according to the current {@link Place} of this knight piece.\n     * All the returned {@link Move} should have source equal to the source parameter.\n     * <p>\n     * Hint: you should consider corner cases when the {@link Move} is not valid on the gameboard.\n     * Several tests are provided and your implementation should pass them.\n     * <p>\n     * <strong>Attention: Student should make sure all {@link Move}s returned are valid.</strong>\n     *\n     * @param game   the game object\n     * @param source the current place of the piece\n     * @return an array of available moves\n     */\n    @Override\n    public Move[] getAvailableMoves(Game game, Place source) {\n        // TODO student implementation\n        return new Move[0];\n    }\n}\n\n```\n\n```java\npackage assignment.piece;\n\n\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\n\n/**\n * Interface that a rule should implement.\n * Every mode in the gameboard should not violate the rule.\n */\npublic interface Rule {\n    /**\n     * Validate the move. if the rule is violated return false.\n     * <p>\n     * [Hint] the piece that is to be moved can be obtained using {@code game.getPiece(move.getSource()}.\n     *\n     * @param game the current game object\n     * @param move the move to be validated\n     * @return true if the rule check pass. If the rule is violated, return false.\n     */\n    public boolean validate(Game game, Move move);\n\n    /**\n     * Returns a string description of the rule, which will be printed as error message when the rule is violated.\n     *\n     * @return description of the rule\n     */\n    public String getDescription();\n}\n\n// Below are several predefined global rules for all moves.\n\n\n```\n\n```java\npackage assignment.protocol;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\n/**\n * The Game class\n */\npublic abstract class Game implements Cloneable {\n    /**\n     * Game configuration\n     */\n    protected Configuration configuration;\n\n    /**\n     * The gameboard, which is a 2-dimensional array of {@link Piece}, representing all the {@link Place} (squares) on\n     * the board.\n     * If there is a piece in some {@link Place} place(x,y), then {@code board[place.x()][place.y()]} will be the\n     * piece object, otherwise null.\n     * In other words, the board is a 2-D array with length equal to size of the board in both dimensions.\n     */\n    protected Piece[][] board;\n\n    /**\n     * Current player who is supposed to make a move.\n     */\n    protected Player currentPlayer;\n\n    /**\n     * The current number of moves made by two players\n     */\n    protected int numMoves = 0;\n\n    public Game(Configuration configuration) {\n        this.configuration = configuration;\n        this.board = configuration.getInitialBoard();\n    }\n\n    /**\n     * Start the game\n     * Players will take turns according to the order in {@link Configuration#getPlayers()} to make a move until\n     * a player wins.\n     *\n     * @return the winner\n     */\n    public abstract Player start();\n\n    /**\n     * Get the winner of the game. If there is no winner yet, return null;\n     *\n     * @param lastPlayer the last player who makes a move\n     * @param lastPiece the last piece that is moved by the player\n     * @param lastMove   the last move made by lastPlayer\n     * @return the winner if it exists, otherwise return null\n     */\n    public abstract Player getWinner(Player lastPlayer, Piece lastPiece, Move lastMove);\n\n    /**\n     * Update the score of a player according to the piece and corresponding move made by him just now.\n     *\n     * @param player the player who just makes a move\n     * @param piece  the piece that is just moved\n     * @param move   the move that is just made\n     */\n    public abstract void updateScore(Player player, Piece piece, Move move);\n\n    /**\n     * Make a move.\n     *\n     * @param move the move to make\n     */\n    public abstract void movePiece(Move move);\n\n    /**\n     * Get all available moves of one player.\n     *\n     * @param player the player whose available moves to get\n     * @return an array of available moves\n     */\n    public abstract Move[] getAvailableMoves(Player player);\n\n    /**\n     * Refresh the output printed in the console, which shows the following things.\n     * 1. the gameboard and pieces on it\n     * 2. scores of the players\n     * 3. other help information\n     */\n    public void refreshOutput() {\n        int size = this.configuration.getSize();\n        ArrayList<List<String>> contents = new ArrayList<List<String>>();\n        for (int row = size - 1; row >= 0; row--) {\n            ArrayList<String> rowContent = new ArrayList<String>();\n            for (int col = 0; col < size; col++) {\n                Piece piece = this.getPiece(col, row);\n                if (piece == null) {\n                    if (this.getCentralPlace().equals(new Place(col, row))) {\n                        rowContent.add(\"x\");\n                    } else {\n                        rowContent.add(\".\");\n                    }\n                } else {\n                    Player player = piece.getPlayer();\n                    rowContent.add(String.format(\"%s%c%s\",\n                            player.getColor(),\n                            piece.getLabel(),\n                            Color.DEFAULT));\n                }\n            }\n            contents.add(rowContent);\n        }\n        ArrayList<String> xCoordinates = new ArrayList<String>();\n        for (int i = 0; i < size; i++) {\n            xCoordinates.add(String.valueOf((char) ('a' + i)));\n        }\n        Collections.reverse(contents);\n\n        // clear screen\n        System.out.print(\"\\u001b[2J\");\n        System.out.flush();\n\n        System.out.println();\n        System.out.println(\"### COMP3021 Programming Assignment 1 ###\");\n        System.out.println();\n        System.out.println(\"Guide: to move a piece, input the coordinate of source and the destination.\");\n        System.out.println(\"For example: a1->b2 means to move the piece at 'a1' to 'b2'\");\n        if (this.numMoves < this.configuration.getNumMovesProtection()) {\n            System.out.println();\n            System.out.println(\"Notice: first \" + this.configuration.getNumMovesProtection() + \" moves are not allowed to\" +\n                    \" capture pieces or win the game.\");\n        }\n        System.out.println();\n        System.out.println(\"Total Moves: \" + this.numMoves);\n        // print scores of players\n        for (Player player :\n                this.configuration.getPlayers()) {\n            System.out.printf(\"%s%s%s score: %d\\n\", player.getColor(), player.getName(), Color.DEFAULT,\n                    player.getScore());\n        }\n        System.out.println();\n        // print the gameboard\n        int leftPadding = 8;\n        StringBuilder paddingSpaceBuilder = new StringBuilder();\n        paddingSpaceBuilder.append(\" \".repeat(leftPadding));\n        System.out.printf(\"%s%s\\n\",\n                paddingSpaceBuilder.toString(),\n                xCoordinates.parallelStream()\n                        .collect(Collectors.joining(\" \")));\n        StringBuilder borderBuilder = new StringBuilder();\n        borderBuilder.append(\"-\".repeat(Math.max(0, contents.get(0).size() * 2 - 1)));\n        System.out.printf(\"%s%s\\n\",\n                paddingSpaceBuilder.toString(),\n                borderBuilder.toString());\n        for (int row = contents.size() - 1; row >= 0; row--) {\n            System.out.printf(\"%\" + (leftPadding - 1) + \"d|%s|%d\\n\",\n                    row + 1,\n                    contents.get(row).parallelStream().map(Object::toString).collect(Collectors.joining(\" \")),\n                    row + 1);\n        }\n        System.out.printf(\"%s%s\\n\",\n                paddingSpaceBuilder.toString(),\n                borderBuilder.toString());\n        System.out.printf(\"%s%s\\n\",\n                paddingSpaceBuilder.toString(),\n                xCoordinates.parallelStream()\n                        .collect(Collectors.joining(\" \")));\n        System.out.println();\n    }\n\n    /**\n     * Get the piece in the place\n     *\n     * @param place the place of the piece\n     * @return the piece\n     */\n    public Piece getPiece(Place place) {\n        return this.board[place.x()][place.y()];\n    }\n\n    public Piece getPiece(int x, int y) {\n        return this.getPiece(new Place(x, y));\n    }\n\n    public Player getCurrentPlayer() {\n        return currentPlayer != null ? currentPlayer : this.configuration.getPlayers()[0];\n    }\n\n    public Player[] getPlayers() {\n        return configuration.getPlayers();\n    }\n\n    public int getNumMoves() {\n        return numMoves;\n    }\n\n    public Configuration getConfiguration() {\n        return configuration;\n    }\n\n    public Place getCentralPlace() {\n        return configuration.getCentralPlace();\n    }\n\n    @Override\n    public Game clone() throws CloneNotSupportedException {\n        Game cloned = (Game) super.clone();\n        cloned.configuration = this.configuration.clone();\n        cloned.board = this.board.clone();\n        for (int i = 0; i < this.configuration.getSize(); i++) {\n            cloned.board[i] = this.board[i].clone();\n            // no need to deep copy pieces\n            if (this.configuration.getSize() >= 0)\n                System.arraycopy(this.board[i], 0, cloned.board[i], 0, this.configuration.getSize());\n        }\n        cloned.currentPlayer = currentPlayer == null ? null : currentPlayer.clone();\n        return cloned;\n    }\n}\n```\n\n```java\npackage assignment.protocol;\n\nimport java.util.Objects;\nimport java.util.StringJoiner;\n\n/**\n * Move class represent a move made by a {@link Player}, moving a piece from one {@link Place} to another {@link Place}.\n */\npublic class Move implements Cloneable {\n    /**\n     * Source place of the move.\n     */\n    private Place source;\n\n    /**\n     * Move destination\n     */\n    private Place destination;\n\n    public Move(Place source, Place destination) {\n        this.source = source;\n        this.destination = destination;\n    }\n\n    public Move(int sourceX, int sourceY, int destinationX, int destinationY) {\n        this(new Place(sourceX, sourceY), new Place(destinationX, destinationY));\n    }\n\n    public Move(Place source, int destinationX, int destinationY) {\n        this(source, new Place(destinationX, destinationY));\n    }\n\n    /* Getters start */\n    public Place getSource() {\n        return source;\n    }\n\n    public Place getDestination() {\n        return destination;\n    }\n    /* Getters end */\n\n    /* Object methods start */\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || "}
{"task_id": "PA20/NilMoveRule.java", "target": "assignment/piece/NilMoveRule.java", "code": "```java\npackage assignment.piece;\n\nimport assignment.piece.Rule;\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\nimport assignment.protocol.Place;\n\n/**\n * Global rule that requires the source and destination of a move should not be the same.\n */\npublic class NilMoveRule implements Rule {\n    @Override\n    public boolean validate(Game game, Move move) {\n        // TODO\n        return false;\n    }\n\n    @Override\n    public String getDescription() {\n        return \"the source and destination of move should be different places\";\n    }\n}\n\n```\n", "code_context": "```java\npackage assignment.piece;\n\n\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\n\n/**\n * Interface that a rule should implement.\n * Every mode in the gameboard should not violate the rule.\n */\npublic interface Rule {\n    /**\n     * Validate the move. if the rule is violated return false.\n     * <p>\n     * [Hint] the piece that is to be moved can be obtained using {@code game.getPiece(move.getSource()}.\n     *\n     * @param game the current game object\n     * @param move the move to be validated\n     * @return true if the rule check pass. If the rule is violated, return false.\n     */\n    public boolean validate(Game game, Move move);\n\n    /**\n     * Returns a string description of the rule, which will be printed as error message when the rule is violated.\n     *\n     * @return description of the rule\n     */\n    public String getDescription();\n}\n\n// Below are several predefined global rules for all moves.\n\n\n```\n\n```java\npackage assignment.protocol;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\n/**\n * The Game class\n */\npublic abstract class Game implements Cloneable {\n    /**\n     * Game configuration\n     */\n    protected Configuration configuration;\n\n    /**\n     * The gameboard, which is a 2-dimensional array of {@link Piece}, representing all the {@link Place} (squares) on\n     * the board.\n     * If there is a piece in some {@link Place} place(x,y), then {@code board[place.x()][place.y()]} will be the\n     * piece object, otherwise null.\n     * In other words, the board is a 2-D array with length equal to size of the board in both dimensions.\n     */\n    protected Piece[][] board;\n\n    /**\n     * Current player who is supposed to make a move.\n     */\n    protected Player currentPlayer;\n\n    /**\n     * The current number of moves made by two players\n     */\n    protected int numMoves = 0;\n\n    public Game(Configuration configuration) {\n        this.configuration = configuration;\n        this.board = configuration.getInitialBoard();\n    }\n\n    /**\n     * Start the game\n     * Players will take turns according to the order in {@link Configuration#getPlayers()} to make a move until\n     * a player wins.\n     *\n     * @return the winner\n     */\n    public abstract Player start();\n\n    /**\n     * Get the winner of the game. If there is no winner yet, return null;\n     *\n     * @param lastPlayer the last player who makes a move\n     * @param lastPiece the last piece that is moved by the player\n     * @param lastMove   the last move made by lastPlayer\n     * @return the winner if it exists, otherwise return null\n     */\n    public abstract Player getWinner(Player lastPlayer, Piece lastPiece, Move lastMove);\n\n    /**\n     * Update the score of a player according to the piece and corresponding move made by him just now.\n     *\n     * @param player the player who just makes a move\n     * @param piece  the piece that is just moved\n     * @param move   the move that is just made\n     */\n    public abstract void updateScore(Player player, Piece piece, Move move);\n\n    /**\n     * Make a move.\n     *\n     * @param move the move to make\n     */\n    public abstract void movePiece(Move move);\n\n    /**\n     * Get all available moves of one player.\n     *\n     * @param player the player whose available moves to get\n     * @return an array of available moves\n     */\n    public abstract Move[] getAvailableMoves(Player player);\n\n    /**\n     * Refresh the output printed in the console, which shows the following things.\n     * 1. the gameboard and pieces on it\n     * 2. scores of the players\n     * 3. other help information\n     */\n    public void refreshOutput() {\n        int size = this.configuration.getSize();\n        ArrayList<List<String>> contents = new ArrayList<List<String>>();\n        for (int row = size - 1; row >= 0; row--) {\n            ArrayList<String> rowContent = new ArrayList<String>();\n            for (int col = 0; col < size; col++) {\n                Piece piece = this.getPiece(col, row);\n                if (piece == null) {\n                    if (this.getCentralPlace().equals(new Place(col, row))) {\n                        rowContent.add(\"x\");\n                    } else {\n                        rowContent.add(\".\");\n                    }\n                } else {\n                    Player player = piece.getPlayer();\n                    rowContent.add(String.format(\"%s%c%s\",\n                            player.getColor(),\n                            piece.getLabel(),\n                            Color.DEFAULT));\n                }\n            }\n            contents.add(rowContent);\n        }\n        ArrayList<String> xCoordinates = new ArrayList<String>();\n        for (int i = 0; i < size; i++) {\n            xCoordinates.add(String.valueOf((char) ('a' + i)));\n        }\n        Collections.reverse(contents);\n\n        // clear screen\n        System.out.print(\"\\u001b[2J\");\n        System.out.flush();\n\n        System.out.println();\n        System.out.println(\"### COMP3021 Programming Assignment 1 ###\");\n        System.out.println();\n        System.out.println(\"Guide: to move a piece, input the coordinate of source and the destination.\");\n        System.out.println(\"For example: a1->b2 means to move the piece at 'a1' to 'b2'\");\n        if (this.numMoves < this.configuration.getNumMovesProtection()) {\n            System.out.println();\n            System.out.println(\"Notice: first \" + this.configuration.getNumMovesProtection() + \" moves are not allowed to\" +\n                    \" capture pieces or win the game.\");\n        }\n        System.out.println();\n        System.out.println(\"Total Moves: \" + this.numMoves);\n        // print scores of players\n        for (Player player :\n                this.configuration.getPlayers()) {\n            System.out.printf(\"%s%s%s score: %d\\n\", player.getColor(), player.getName(), Color.DEFAULT,\n                    player.getScore());\n        }\n        System.out.println();\n        // print the gameboard\n        int leftPadding = 8;\n        StringBuilder paddingSpaceBuilder = new StringBuilder();\n        paddingSpaceBuilder.append(\" \".repeat(leftPadding));\n        System.out.printf(\"%s%s\\n\",\n                paddingSpaceBuilder.toString(),\n                xCoordinates.parallelStream()\n                        .collect(Collectors.joining(\" \")));\n        StringBuilder borderBuilder = new StringBuilder();\n        borderBuilder.append(\"-\".repeat(Math.max(0, contents.get(0).size() * 2 - 1)));\n        System.out.printf(\"%s%s\\n\",\n                paddingSpaceBuilder.toString(),\n                borderBuilder.toString());\n        for (int row = contents.size() - 1; row >= 0; row--) {\n            System.out.printf(\"%\" + (leftPadding - 1) + \"d|%s|%d\\n\",\n                    row + 1,\n                    contents.get(row).parallelStream().map(Object::toString).collect(Collectors.joining(\" \")),\n                    row + 1);\n        }\n        System.out.printf(\"%s%s\\n\",\n                paddingSpaceBuilder.toString(),\n                borderBuilder.toString());\n        System.out.printf(\"%s%s\\n\",\n                paddingSpaceBuilder.toString(),\n                xCoordinates.parallelStream()\n                        .collect(Collectors.joining(\" \")));\n        System.out.println();\n    }\n\n    /**\n     * Get the piece in the place\n     *\n     * @param place the place of the piece\n     * @return the piece\n     */\n    public Piece getPiece(Place place) {\n        return this.board[place.x()][place.y()];\n    }\n\n    public Piece getPiece(int x, int y) {\n        return this.getPiece(new Place(x, y));\n    }\n\n    public Player getCurrentPlayer() {\n        return currentPlayer != null ? currentPlayer : this.configuration.getPlayers()[0];\n    }\n\n    public Player[] getPlayers() {\n        return configuration.getPlayers();\n    }\n\n    public int getNumMoves() {\n        return numMoves;\n    }\n\n    public Configuration getConfiguration() {\n        return configuration;\n    }\n\n    public Place getCentralPlace() {\n        return configuration.getCentralPlace();\n    }\n\n    @Override\n    public Game clone() throws CloneNotSupportedException {\n        Game cloned = (Game) super.clone();\n        cloned.configuration = this.configuration.clone();\n        cloned.board = this.board.clone();\n        for (int i = 0; i < this.configuration.getSize(); i++) {\n            cloned.board[i] = this.board[i].clone();\n            // no need to deep copy pieces\n            if (this.configuration.getSize() >= 0)\n                System.arraycopy(this.board[i], 0, cloned.board[i], 0, this.configuration.getSize());\n        }\n        cloned.currentPlayer = currentPlayer == null ? null : currentPlayer.clone();\n        return cloned;\n    }\n}\n```\n\n```java\npackage assignment.protocol;\n\nimport java.util.Objects;\nimport java.util.StringJoiner;\n\n/**\n * Move class represent a move made by a {@link Player}, moving a piece from one {@link Place} to another {@link Place}.\n */\npublic class Move implements Cloneable {\n    /**\n     * Source place of the move.\n     */\n    private Place source;\n\n    /**\n     * Move destination\n     */\n    private Place destination;\n\n    public Move(Place source, Place destination) {\n        this.source = source;\n        this.destination = destination;\n    }\n\n    public Move(int sourceX, int sourceY, int destinationX, int destinationY) {\n        this(new Place(sourceX, sourceY), new Place(destinationX, destinationY));\n    }\n\n    public Move(Place source, int destinationX, int destinationY) {\n        this(source, new Place(destinationX, destinationY));\n    }\n\n    /* Getters start */\n    public Place getSource() {\n        return source;\n    }\n\n    public Place getDestination() {\n        return destination;\n    }\n    /* Getters end */\n\n    /* Object methods start */\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Move move = (Move) o;\n        return source.equals(move.source) &&\n                destination.equals(move.destination);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(source, destination);\n    }\n\n    @Override\n    public String toString() {\n        return new StringJoiner(\", \", Move.class.getSimpleName() + \"[\", \"]\")\n                .add(\"source=\" + source)\n                .add(\"destination=\" + destination)\n                .toString();\n    }\n\n    @Override\n    public Move clone() throws CloneNotSupportedException {\n        Move cloned = (Move) super.clone();\n        cloned.source = this.source.clone();\n        cloned.destination = this.destination.clone();\n        return cloned;\n    }\n\n    /* Object methods end */\n\n}\n\n```\n\n```java\npackage assignment.protocol;\n\n/**\n * A square (position, place) in the gameboard.\n * Represented by coordinates a 2-D coordinate system.\n * <p>\n * x and y coordinates of a place on gameboard are two fields of this class.\n */\npublic class Place implements Cloneable {\n    private int x;\n\n    private int y;\n\n    public Place(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public int x() {\n        return x;\n    }\n\n    public void x(int x) {\n        this.x = x;\n    }\n\n    public int y() {\n        return y;\n    }\n\n    public void y(int y) {\n        this.y = y;\n    }\n\n    @Override\n    public Place clone() throws CloneNotSupportedException {\n        return (Place) super.clone();\n    }\n}\n```\n"}
{"task_id": "PA20/OccupiedRule.java", "target": "assignment/piece/OccupiedRule.java", "code": "```java\npackage assignment.piece;\n\nimport assignment.piece.Rule;\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\nimport assignment.protocol.Piece;\nimport assignment.protocol.Place;\nimport assignment.protocol.Player;\n\n/**\n * Global rule that requires that a piece should not go to a destination where there is another piece belonging to the\n * same player.\n */\npublic class OccupiedRule implements Rule {\n    @Override\n    public boolean validate(Game game, Move move) {\n        // TODO\n        return false;\n    }\n\n    @Override\n    public String getDescription() {\n        return \"piece cannot be captured by another piece belonging to the same player\";\n    }\n}\n\n```\n", "code_context": "```java\npackage assignment.piece;\n\n\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\n\n/**\n * Interface that a rule should implement.\n * Every mode in the gameboard should not violate the rule.\n */\npublic interface Rule {\n    /**\n     * Validate the move. if the rule is violated return false.\n     * <p>\n     * [Hint] the piece that is to be moved can be obtained using {@code game.getPiece(move.getSource()}.\n     *\n     * @param game the current game object\n     * @param move the move to be validated\n     * @return true if the rule check pass. If the rule is violated, return false.\n     */\n    public boolean validate(Game game, Move move);\n\n    /**\n     * Returns a string description of the rule, which will be printed as error message when the rule is violated.\n     *\n     * @return description of the rule\n     */\n    public String getDescription();\n}\n\n// Below are several predefined global rules for all moves.\n\n\n```\n\n```java\npackage assignment.protocol;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\n/**\n * The Game class\n */\npublic abstract class Game implements Cloneable {\n    /**\n     * Game configuration\n     */\n    protected Configuration configuration;\n\n    /**\n     * The gameboard, which is a 2-dimensional array of {@link Piece}, representing all the {@link Place} (squares) on\n     * the board.\n     * If there is a piece in some {@link Place} place(x,y), then {@code board[place.x()][place.y()]} will be the\n     * piece object, otherwise null.\n     * In other words, the board is a 2-D array with length equal to size of the board in both dimensions.\n     */\n    protected Piece[][] board;\n\n    /**\n     * Current player who is supposed to make a move.\n     */\n    protected Player currentPlayer;\n\n    /**\n     * The current number of moves made by two players\n     */\n    protected int numMoves = 0;\n\n    public Game(Configuration configuration) {\n        this.configuration = configuration;\n        this.board = configuration.getInitialBoard();\n    }\n\n    /**\n     * Start the game\n     * Players will take turns according to the order in {@link Configuration#getPlayers()} to make a move until\n     * a player wins.\n     *\n     * @return the winner\n     */\n    public abstract Player start();\n\n    /**\n     * Get the winner of the game. If there is no winner yet, return null;\n     *\n     * @param lastPlayer the last player who makes a move\n     * @param lastPiece the last piece that is moved by the player\n     * @param lastMove   the last move made by lastPlayer\n     * @return the winner if it exists, otherwise return null\n     */\n    public abstract Player getWinner(Player lastPlayer, Piece lastPiece, Move lastMove);\n\n    /**\n     * Update the score of a player according to the piece and corresponding move made by him just now.\n     *\n     * @param player the player who just makes a move\n     * @param piece  the piece that is just moved\n     * @param move   the move that is just made\n     */\n    public abstract void updateScore(Player player, Piece piece, Move move);\n\n    /**\n     * Make a move.\n     *\n     * @param move the move to make\n     */\n    public abstract void movePiece(Move move);\n\n    /**\n     * Get all available moves of one player.\n     *\n     * @param player the player whose available moves to get\n     * @return an array of available moves\n     */\n    public abstract Move[] getAvailableMoves(Player player);\n\n    /**\n     * Refresh the output printed in the console, which shows the following things.\n     * 1. the gameboard and pieces on it\n     * 2. scores of the players\n     * 3. other help information\n     */\n    public void refreshOutput() {\n        int size = this.configuration.getSize();\n        ArrayList<List<String>> contents = new ArrayList<List<String>>();\n        for (int row = size - 1; row >= 0; row--) {\n            ArrayList<String> rowContent = new ArrayList<String>();\n            for (int col = 0; col < size; col++) {\n                Piece piece = this.getPiece(col, row);\n                if (piece == null) {\n                    if (this.getCentralPlace().equals(new Place(col, row))) {\n                        rowContent.add(\"x\");\n                    } else {\n                        rowContent.add(\".\");\n                    }\n                } else {\n                    Player player = piece.getPlayer();\n                    rowContent.add(String.format(\"%s%c%s\",\n                            player.getColor(),\n                            piece.getLabel(),\n                            Color.DEFAULT));\n                }\n            }\n            contents.add(rowContent);\n        }\n        ArrayList<String> xCoordinates = new ArrayList<String>();\n        for (int i = 0; i < size; i++) {\n            xCoordinates.add(String.valueOf((char) ('a' + i)));\n        }\n        Collections.reverse(contents);\n\n        // clear screen\n        System.out.print(\"\\u001b[2J\");\n        System.out.flush();\n\n        System.out.println();\n        System.out.println(\"### COMP3021 Programming Assignment 1 ###\");\n        System.out.println();\n        System.out.println(\"Guide: to move a piece, input the coordinate of source and the destination.\");\n        System.out.println(\"For example: a1->b2 means to move the piece at 'a1' to 'b2'\");\n        if (this.numMoves < this.configuration.getNumMovesProtection()) {\n            System.out.println();\n            System.out.println(\"Notice: first \" + this.configuration.getNumMovesProtection() + \" moves are not allowed to\" +\n                    \" capture pieces or win the game.\");\n        }\n        System.out.println();\n        System.out.println(\"Total Moves: \" + this.numMoves);\n        // print scores of players\n        for (Player player :\n                this.configuration.getPlayers()) {\n            System.out.printf(\"%s%s%s score: %d\\n\", player.getColor(), player.getName(), Color.DEFAULT,\n                    player.getScore());\n        }\n        System.out.println();\n        // print the gameboard\n        int leftPadding = 8;\n        StringBuilder paddingSpaceBuilder = new StringBuilder();\n        paddingSpaceBuilder.append(\" \".repeat(leftPadding));\n        System.out.printf(\"%s%s\\n\",\n                paddingSpaceBuilder.toString(),\n                xCoordinates.parallelStream()\n                        .collect(Collectors.joining(\" \")));\n        StringBuilder borderBuilder = new StringBuilder();\n        borderBuilder.append(\"-\".repeat(Math.max(0, contents.get(0).size() * 2 - 1)));\n        System.out.printf(\"%s%s\\n\",\n                paddingSpaceBuilder.toString(),\n                borderBuilder.toString());\n        for (int row = contents.size() - 1; row >= 0; row--) {\n            System.out.printf(\"%\" + (leftPadding - 1) + \"d|%s|%d\\n\",\n                    row + 1,\n                    contents.get(row).parallelStream().map(Object::toString).collect(Collectors.joining(\" \")),\n                    row + 1);\n        }\n        System.out.printf(\"%s%s\\n\",\n                paddingSpaceBuilder.toString(),\n                borderBuilder.toString());\n        System.out.printf(\"%s%s\\n\",\n                paddingSpaceBuilder.toString(),\n                xCoordinates.parallelStream()\n                        .collect(Collectors.joining(\" \")));\n        System.out.println();\n    }\n\n    /**\n     * Get the piece in the place\n     *\n     * @param place the place of the piece\n     * @return the piece\n     */\n    public Piece getPiece(Place place) {\n        return this.board[place.x()][place.y()];\n    }\n\n    public Piece getPiece(int x, int y) {\n        return this.getPiece(new Place(x, y));\n    }\n\n    public Player getCurrentPlayer() {\n        return currentPlayer != null ? currentPlayer : this.configuration.getPlayers()[0];\n    }\n\n    public Player[] getPlayers() {\n        return configuration.getPlayers();\n    }\n\n    public int getNumMoves() {\n        return numMoves;\n    }\n\n    public Configuration getConfiguration() {\n        return configuration;\n    }\n\n    public Place getCentralPlace() {\n        return configuration.getCentralPlace();\n    }\n\n    @Override\n    public Game clone() throws CloneNotSupportedException {\n        Game cloned = (Game) super.clone();\n        cloned.configuration = this.configuration.clone();\n        cloned.board = this.board.clone();\n        for (int i = 0; i < this.configuration.getSize(); i++) {\n            cloned.board[i] = this.board[i].clone();\n            // no need to deep copy pieces\n            if (this.configuration.getSize() >= 0)\n                System.arraycopy(this.board[i], 0, cloned.board[i], 0, this.configuration.getSize());\n        }\n        cloned.currentPlayer = currentPlayer == null ? null : currentPlayer.clone();\n        return cloned;\n    }\n}\n```\n\n```java\npackage assignment.protocol;\n\nimport java.util.Objects;\nimport java.util.StringJoiner;\n\n/**\n * Move class represent a move made by a {@link Player}, moving a piece from one {@link Place} to another {@link Place}.\n */\npublic class Move implements Cloneable {\n    /**\n     * Source place of the move.\n     */\n    private Place source;\n\n    /**\n     * Move destination\n     */\n    private Place destination;\n\n    public Move(Place source, Place destination) {\n        this.source = source;\n        this.destination = destination;\n    }\n\n    public Move(int sourceX, int sourceY, int destinationX, int destinationY) {\n        this(new Place(sourceX, sourceY), new Place(destinationX, destinationY));\n    }\n\n    public Move(Place source, int destinationX, int destinationY) {\n        this(source, new Place(destinationX, destinationY));\n    }\n\n    /* Getters start */\n    public Place getSource() {\n        return source;\n    }\n\n    public Place getDestination() {\n        return destination;\n    }\n    /* Getters end */\n\n    /* Object methods start */\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Move move = (Move) o;\n        return source.equals(move.source) &&\n                destination.equals(move.destination);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(source, destination);\n    }\n\n    @Override\n    public String toString() {\n        return new StringJoiner(\", \", Move.class.getSimpleName() + \"[\", \"]\")\n                .add(\"source=\" + source)\n                .add(\"destination=\" + destination)\n                .toString();\n    }\n\n    @Override\n    public Move clone() throws CloneNotSupportedException {\n        Move cloned = (Move) super.clone();\n        cloned.source = this.source.clone();\n        cloned.destination = this.destination.clone();\n        return cloned;\n    }\n\n    /* Object methods end */\n\n}\n\n```\n\n```java\npackage assignment.protocol;\n\n/**\n * A square (position, place) in the gameboard.\n * Represented by coordinates a 2-D coordinate system.\n * <p>\n * x and y coordinates of a place on gameboard are two fields of this class.\n */\npublic class Place implements Cloneable {\n    private int x;\n\n    private int y;\n\n    public Place(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public int x() {\n        return x;\n    }\n\n    public void x(int x) {\n        this.x = x;\n    }\n\n    public int y() {\n        return y;\n    }\n\n    public void y(int y) {\n        this.y = y;\n    }\n\n    @Override\n    public Place clone() throws CloneNotSupportedException {\n        return (Place) super.clone();\n    }\n}\n```\n\n```java\npackage assignment.protocol;\n\n\n/**\n * The abstract class that a game piece should extend.\n */\npublic abstract class Piece {\n    /**\n     * The player that owns this piece.\n     */\n    private final Player player;\n\n    public Piece(Player player) {\n        this.player = player;\n    }\n\n    public final Player getPlayer() {\n        return this.player;\n    }\n\n    /**\n     * Returns a char which is used to facilitate output in the console\n     *\n     * @return the label to represent the piece on the board\n     */\n    public abstract char getLabel();\n\n    /**\n     * Returns an array of moves that are valid given the current place of the piece.\n     *\n     * @param game   the game object\n     * @param source the current place of the piece\n     * @return a set of "}
{"task_id": "PA20/OutOfBoundaryRule.java", "target": "assignment/piece/OutOfBoundaryRule.java", "code": "```java\npackage assignment.piece;\n\nimport assignment.piece.Rule;\nimport assignment.protocol.Configuration;\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\nimport assignment.protocol.Place;\n\n/**\n * Global rule that requires the source and destination should be inside the board boundary.\n */\npublic class OutOfBoundaryRule implements Rule {\n    @Override\n    public boolean validate(Game game, Move move) {\n        // TODO\n        return false;\n    }\n\n    @Override\n    public String getDescription() {\n        return \"place is out of boundary of gameboard\";\n    }\n}\n\n```\n", "code_context": "```java\npackage assignment.piece;\n\n\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\n\n/**\n * Interface that a rule should implement.\n * Every mode in the gameboard should not violate the rule.\n */\npublic interface Rule {\n    /**\n     * Validate the move. if the rule is violated return false.\n     * <p>\n     * [Hint] the piece that is to be moved can be obtained using {@code game.getPiece(move.getSource()}.\n     *\n     * @param game the current game object\n     * @param move the move to be validated\n     * @return true if the rule check pass. If the rule is violated, return false.\n     */\n    public boolean validate(Game game, Move move);\n\n    /**\n     * Returns a string description of the rule, which will be printed as error message when the rule is violated.\n     *\n     * @return description of the rule\n     */\n    public String getDescription();\n}\n\n// Below are several predefined global rules for all moves.\n\n\n```\n\n```java\npackage assignment.protocol;\n\nimport assignment.protocol.exception.InvalidConfigurationError;\n\n/**\n * Game configuration, including:\n * 1. size of gameboard\n * 2. place (square) of central square in classical Jeson Mor\n * 3. the initial game board with pieces on it, which is configurable through {@link Configuration#addInitialPiece(Piece, Place)}\n * 4. the two players.\n */\npublic class Configuration implements Cloneable {\n    /**\n     * Size of gameboard.\n     * The gameboard has equal size in width and height.\n     * The size should be an odd number.\n     */\n    private final int size;\n\n    /**\n     * An array of two players in the game.\n     * Note that in the implementation of {@link Game#start()} the first player in this array moves first when game\n     * starts.\n     */\n    private Player[] players;\n\n    /**\n     * The initial map of the gameboard, containing initial pieces and their places.\n     * This map has keys for all places in the gameboard, with or without pieces.\n     * If there is no piece in one place, the place is mapped to null.\n     */\n    private Piece[][] initialBoard;\n\n    /**\n     * The central square of the gameboard.\n     */\n    private Place centralPlace;\n\n    /**\n     * This number means: within the first {@code numMovesProtection} number of moves in the game, capturing\n     * {@link Piece}s is not allowed.\n     */\n    private final int numMovesProtection;\n\n    /**\n     * Constructor of configuration\n     *\n     * @param size size of the gameboard.\n     * @param players an array of two players in the game, the first player should move first when game starts.\n     * @param numMovesProtection the first number of moves where capturing pieces is not allowed\n     */\n    public Configuration(int size, Player[] players, int numMovesProtection) {\n        // validate size\n        if (size < 3) {\n            throw new InvalidConfigurationError(\"size of gameboard must be at least 3\");\n        }\n        if (size % 2 != 1) {\n            throw new InvalidConfigurationError(\"size of gameboard must be an odd number\");\n        }\n        if (size > 25) {\n            throw new InvalidConfigurationError(\"size of gameboard is at most 25\");\n        }\n        this.size = size;\n        // We only have 2 players\n        this.players = players;\n        if (players.length != 2) {\n            throw new InvalidConfigurationError(\"there must be exactly two players\");\n        }\n        // initialize map of the game board by putting every place null (meaning no piece)\n        this.initialBoard = new Piece[size][];\n        for (int x = 0; x < size; x++) {\n            this.initialBoard[x] = new Piece[size];\n            for (int y = 0; y < size; y++) {\n                this.initialBoard[x][y] = null;\n            }\n        }\n        // calculate the central place\n        this.centralPlace = new Place(size / 2, size / 2);\n\n        if (numMovesProtection < 0) {\n            throw new InvalidConfigurationError(\"number of moves with capture protection cannot be negative\");\n        }\n        this.numMovesProtection = numMovesProtection;\n    }\n\n    public Configuration(int size, Player[] players) {\n        this(size, players, 0);\n    }\n\n    /**\n     * Add piece to the initial gameboard.\n     * The player that this piece belongs to will be automatically added into the configuration.\n     *\n     * @param piece piece to be added\n     * @param place place to put the piece\n     */\n    public void addInitialPiece(Piece piece, Place place) {\n        if (!piece.getPlayer().equals(this.players[0]) && !piece.getPlayer().equals(this.players[1])) {\n            throw new InvalidConfigurationError(\"the player of the piece is unknown\");\n        }\n        if (place.x() >= this.size || place.y() >= this.size) {\n            // The place must be inside the gameboard\n            throw new InvalidConfigurationError(\"the place\" + place.toString() + \" must be inside the gameboard\");\n        }\n        if (place.equals(this.centralPlace)) {\n            throw new InvalidConfigurationError(\"piece cannot be put at central place initially\");\n        }\n\n        // put the piece on the initial board\n        this.initialBoard[place.x()][place.y()] = piece;\n    }\n\n    public void addInitialPiece(Piece piece, int x, int y) {\n        this.addInitialPiece(piece, new Place(x, y));\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public Player[] getPlayers() {\n        return players;\n    }\n\n    public Piece[][] getInitialBoard() {\n        return initialBoard;\n    }\n\n    public Place getCentralPlace() {\n        return centralPlace;\n    }\n\n    public int getNumMovesProtection() {\n        return numMovesProtection;\n    }\n\n    @Override\n    public Configuration clone() throws CloneNotSupportedException {\n        Configuration cloned = (Configuration) super.clone();\n        cloned.players = this.players.clone();\n        for (int i = 0; i < this.players.length; i++) {\n            cloned.players[i] = this.players[i].clone();\n        }\n        cloned.initialBoard = this.initialBoard.clone();\n        for (int i = 0; i < this.size; i++) {\n            cloned.initialBoard[i] = this.initialBoard[i].clone();\n            // no need to deep copy piece\n            System.arraycopy(this.initialBoard[i], 0, cloned.initialBoard[i], 0, this.size);\n        }\n        cloned.centralPlace = this.centralPlace.clone();\n        return cloned;\n    }\n}\n\n```\n\n```java\npackage assignment.protocol;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\n/**\n * The Game class\n */\npublic abstract class Game implements Cloneable {\n    /**\n     * Game configuration\n     */\n    protected Configuration configuration;\n\n    /**\n     * The gameboard, which is a 2-dimensional array of {@link Piece}, representing all the {@link Place} (squares) on\n     * the board.\n     * If there is a piece in some {@link Place} place(x,y), then {@code board[place.x()][place.y()]} will be the\n     * piece object, otherwise null.\n     * In other words, the board is a 2-D array with length equal to size of the board in both dimensions.\n     */\n    protected Piece[][] board;\n\n    /**\n     * Current player who is supposed to make a move.\n     */\n    protected Player currentPlayer;\n\n    /**\n     * The current number of moves made by two players\n     */\n    protected int numMoves = 0;\n\n    public Game(Configuration configuration) {\n        this.configuration = configuration;\n        this.board = configuration.getInitialBoard();\n    }\n\n    /**\n     * Start the game\n     * Players will take turns according to the order in {@link Configuration#getPlayers()} to make a move until\n     * a player wins.\n     *\n     * @return the winner\n     */\n    public abstract Player start();\n\n    /**\n     * Get the winner of the game. If there is no winner yet, return null;\n     *\n     * @param lastPlayer the last player who makes a move\n     * @param lastPiece the last piece that is moved by the player\n     * @param lastMove   the last move made by lastPlayer\n     * @return the winner if it exists, otherwise return null\n     */\n    public abstract Player getWinner(Player lastPlayer, Piece lastPiece, Move lastMove);\n\n    /**\n     * Update the score of a player according to the piece and corresponding move made by him just now.\n     *\n     * @param player the player who just makes a move\n     * @param piece  the piece that is just moved\n     * @param move   the move that is just made\n     */\n    public abstract void updateScore(Player player, Piece piece, Move move);\n\n    /**\n     * Make a move.\n     *\n     * @param move the move to make\n     */\n    public abstract void movePiece(Move move);\n\n    /**\n     * Get all available moves of one player.\n     *\n     * @param player the player whose available moves to get\n     * @return an array of available moves\n     */\n    public abstract Move[] getAvailableMoves(Player player);\n\n    /**\n     * Refresh the output printed in the console, which shows the following things.\n     * 1. the gameboard and pieces on it\n     * 2. scores of the players\n     * 3. other help information\n     */\n    public void refreshOutput() {\n        int size = this.configuration.getSize();\n        ArrayList<List<String>> contents = new ArrayList<List<String>>();\n        for (int row = size - 1; row >= 0; row--) {\n            ArrayList<String> rowContent = new ArrayList<String>();\n            for (int col = 0; col < size; col++) {\n                Piece piece = this.getPiece(col, row);\n                if (piece == null) {\n                    if (this.getCentralPlace().equals(new Place(col, row))) {\n                        rowContent.add(\"x\");\n                    } else {\n                        rowContent.add(\".\");\n                    }\n                } else {\n                    Player player = piece.getPlayer();\n                    rowContent.add(String.format(\"%s%c%s\",\n                            player.getColor(),\n                            piece.getLabel(),\n                            Color.DEFAULT));\n                }\n            }\n            contents.add(rowContent);\n        }\n        ArrayList<String> xCoordinates = new ArrayList<String>();\n        for (int i = 0; i < size; i++) {\n            xCoordinates.add(String.valueOf((char) ('a' + i)));\n        }\n        Collections.reverse(contents);\n\n        // clear screen\n        System.out.print(\"\\u001b[2J\");\n        System.out.flush();\n\n        System.out.println();\n        System.out.println(\"### COMP3021 Programming Assignment 1 ###\");\n        System.out.println();\n        System.out.println(\"Guide: to move a piece, input the coordinate of source and the destination.\");\n        System.out.println(\"For example: a1->b2 means to move the piece at 'a1' to 'b2'\");\n        if (this.numMoves < this.configuration.getNumMovesProtection()) {\n            System.out.println();\n            System.out.println(\"Notice: first \" + this.configuration.getNumMovesProtection() + \" moves are not allowed to\" +\n                    \" capture pieces or win the game.\");\n        }\n        System.out.println();\n        System.out.println(\"Total Moves: \" + this.numMoves);\n        // print scores of players\n        for (Player player :\n                this.configuration.getPlayers()) {\n            System.out.printf(\"%s%s%s score: %d\\n\", player.getColor(), player.getName(), Color.DEFAULT,\n                    player.getScore());\n        }\n        System.out.println();\n        // print the gameboard\n        int leftPadding = 8;\n        StringBuilder paddingSpaceBuilder = new StringBuilder();\n        paddingSpaceBuilder.append(\" \".repeat(leftPadding));\n        System.out.printf(\"%s%s\\n\",\n                paddingSpaceBuilder.toString(),\n                xCoordinates.parallelStream()\n                        .collect(Collectors.joining(\" \")));\n        StringBuilder borderBuilder = new StringBuilder();\n        borderBuilder.append(\"-\".repeat(Math.max(0, contents.get(0).size() * 2 - 1)));\n        System.out.printf(\"%s%s\\n\",\n                paddingSpaceBuilder.toString(),\n                borderBuilder.toString());\n        for (int row = contents.size() - 1; row >= 0; row--) {\n            System.out.printf(\"%\" + (leftPadding - 1) + \"d|%s|%d\\n\",\n                    row + 1,\n                    contents.get(row).pa"}
{"task_id": "PA20/VacantRule.java", "target": "assignment/piece/VacantRule.java", "code": "```java\npackage assignment.piece;\n\nimport assignment.piece.Rule;\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\nimport assignment.protocol.Piece;\nimport assignment.protocol.Place;\n\n/**\n * Global rule that requires the source place of a move must have a piece on it.\n */\npublic class VacantRule implements Rule {\n    @Override\n    public boolean validate(Game game, Move move) {\n        // TODO student implementation\n        return false;\n    }\n\n    @Override\n    public String getDescription() {\n        return \"the source of move should have a piece\";\n    }\n}\n\n```\n", "code_context": "```java\npackage assignment.piece;\n\n\nimport assignment.protocol.Game;\nimport assignment.protocol.Move;\n\n/**\n * Interface that a rule should implement.\n * Every mode in the gameboard should not violate the rule.\n */\npublic interface Rule {\n    /**\n     * Validate the move. if the rule is violated return false.\n     * <p>\n     * [Hint] the piece that is to be moved can be obtained using {@code game.getPiece(move.getSource()}.\n     *\n     * @param game the current game object\n     * @param move the move to be validated\n     * @return true if the rule check pass. If the rule is violated, return false.\n     */\n    public boolean validate(Game game, Move move);\n\n    /**\n     * Returns a string description of the rule, which will be printed as error message when the rule is violated.\n     *\n     * @return description of the rule\n     */\n    public String getDescription();\n}\n\n// Below are several predefined global rules for all moves.\n\n\n```\n\n```java\npackage assignment.protocol;\n\nimport java.util.*;\nimport java.util.stream.Collectors;\n\n/**\n * The Game class\n */\npublic abstract class Game implements Cloneable {\n    /**\n     * Game configuration\n     */\n    protected Configuration configuration;\n\n    /**\n     * The gameboard, which is a 2-dimensional array of {@link Piece}, representing all the {@link Place} (squares) on\n     * the board.\n     * If there is a piece in some {@link Place} place(x,y), then {@code board[place.x()][place.y()]} will be the\n     * piece object, otherwise null.\n     * In other words, the board is a 2-D array with length equal to size of the board in both dimensions.\n     */\n    protected Piece[][] board;\n\n    /**\n     * Current player who is supposed to make a move.\n     */\n    protected Player currentPlayer;\n\n    /**\n     * The current number of moves made by two players\n     */\n    protected int numMoves = 0;\n\n    public Game(Configuration configuration) {\n        this.configuration = configuration;\n        this.board = configuration.getInitialBoard();\n    }\n\n    /**\n     * Start the game\n     * Players will take turns according to the order in {@link Configuration#getPlayers()} to make a move until\n     * a player wins.\n     *\n     * @return the winner\n     */\n    public abstract Player start();\n\n    /**\n     * Get the winner of the game. If there is no winner yet, return null;\n     *\n     * @param lastPlayer the last player who makes a move\n     * @param lastPiece the last piece that is moved by the player\n     * @param lastMove   the last move made by lastPlayer\n     * @return the winner if it exists, otherwise return null\n     */\n    public abstract Player getWinner(Player lastPlayer, Piece lastPiece, Move lastMove);\n\n    /**\n     * Update the score of a player according to the piece and corresponding move made by him just now.\n     *\n     * @param player the player who just makes a move\n     * @param piece  the piece that is just moved\n     * @param move   the move that is just made\n     */\n    public abstract void updateScore(Player player, Piece piece, Move move);\n\n    /**\n     * Make a move.\n     *\n     * @param move the move to make\n     */\n    public abstract void movePiece(Move move);\n\n    /**\n     * Get all available moves of one player.\n     *\n     * @param player the player whose available moves to get\n     * @return an array of available moves\n     */\n    public abstract Move[] getAvailableMoves(Player player);\n\n    /**\n     * Refresh the output printed in the console, which shows the following things.\n     * 1. the gameboard and pieces on it\n     * 2. scores of the players\n     * 3. other help information\n     */\n    public void refreshOutput() {\n        int size = this.configuration.getSize();\n        ArrayList<List<String>> contents = new ArrayList<List<String>>();\n        for (int row = size - 1; row >= 0; row--) {\n            ArrayList<String> rowContent = new ArrayList<String>();\n            for (int col = 0; col < size; col++) {\n                Piece piece = this.getPiece(col, row);\n                if (piece == null) {\n                    if (this.getCentralPlace().equals(new Place(col, row))) {\n                        rowContent.add(\"x\");\n                    } else {\n                        rowContent.add(\".\");\n                    }\n                } else {\n                    Player player = piece.getPlayer();\n                    rowContent.add(String.format(\"%s%c%s\",\n                            player.getColor(),\n                            piece.getLabel(),\n                            Color.DEFAULT));\n                }\n            }\n            contents.add(rowContent);\n        }\n        ArrayList<String> xCoordinates = new ArrayList<String>();\n        for (int i = 0; i < size; i++) {\n            xCoordinates.add(String.valueOf((char) ('a' + i)));\n        }\n        Collections.reverse(contents);\n\n        // clear screen\n        System.out.print(\"\\u001b[2J\");\n        System.out.flush();\n\n        System.out.println();\n        System.out.println(\"### COMP3021 Programming Assignment 1 ###\");\n        System.out.println();\n        System.out.println(\"Guide: to move a piece, input the coordinate of source and the destination.\");\n        System.out.println(\"For example: a1->b2 means to move the piece at 'a1' to 'b2'\");\n        if (this.numMoves < this.configuration.getNumMovesProtection()) {\n            System.out.println();\n            System.out.println(\"Notice: first \" + this.configuration.getNumMovesProtection() + \" moves are not allowed to\" +\n                    \" capture pieces or win the game.\");\n        }\n        System.out.println();\n        System.out.println(\"Total Moves: \" + this.numMoves);\n        // print scores of players\n        for (Player player :\n                this.configuration.getPlayers()) {\n            System.out.printf(\"%s%s%s score: %d\\n\", player.getColor(), player.getName(), Color.DEFAULT,\n                    player.getScore());\n        }\n        System.out.println();\n        // print the gameboard\n        int leftPadding = 8;\n        StringBuilder paddingSpaceBuilder = new StringBuilder();\n        paddingSpaceBuilder.append(\" \".repeat(leftPadding));\n        System.out.printf(\"%s%s\\n\",\n                paddingSpaceBuilder.toString(),\n                xCoordinates.parallelStream()\n                        .collect(Collectors.joining(\" \")));\n        StringBuilder borderBuilder = new StringBuilder();\n        borderBuilder.append(\"-\".repeat(Math.max(0, contents.get(0).size() * 2 - 1)));\n        System.out.printf(\"%s%s\\n\",\n                paddingSpaceBuilder.toString(),\n                borderBuilder.toString());\n        for (int row = contents.size() - 1; row >= 0; row--) {\n            System.out.printf(\"%\" + (leftPadding - 1) + \"d|%s|%d\\n\",\n                    row + 1,\n                    contents.get(row).parallelStream().map(Object::toString).collect(Collectors.joining(\" \")),\n                    row + 1);\n        }\n        System.out.printf(\"%s%s\\n\",\n                paddingSpaceBuilder.toString(),\n                borderBuilder.toString());\n        System.out.printf(\"%s%s\\n\",\n                paddingSpaceBuilder.toString(),\n                xCoordinates.parallelStream()\n                        .collect(Collectors.joining(\" \")));\n        System.out.println();\n    }\n\n    /**\n     * Get the piece in the place\n     *\n     * @param place the place of the piece\n     * @return the piece\n     */\n    public Piece getPiece(Place place) {\n        return this.board[place.x()][place.y()];\n    }\n\n    public Piece getPiece(int x, int y) {\n        return this.getPiece(new Place(x, y));\n    }\n\n    public Player getCurrentPlayer() {\n        return currentPlayer != null ? currentPlayer : this.configuration.getPlayers()[0];\n    }\n\n    public Player[] getPlayers() {\n        return configuration.getPlayers();\n    }\n\n    public int getNumMoves() {\n        return numMoves;\n    }\n\n    public Configuration getConfiguration() {\n        return configuration;\n    }\n\n    public Place getCentralPlace() {\n        return configuration.getCentralPlace();\n    }\n\n    @Override\n    public Game clone() throws CloneNotSupportedException {\n        Game cloned = (Game) super.clone();\n        cloned.configuration = this.configuration.clone();\n        cloned.board = this.board.clone();\n        for (int i = 0; i < this.configuration.getSize(); i++) {\n            cloned.board[i] = this.board[i].clone();\n            // no need to deep copy pieces\n            if (this.configuration.getSize() >= 0)\n                System.arraycopy(this.board[i], 0, cloned.board[i], 0, this.configuration.getSize());\n        }\n        cloned.currentPlayer = currentPlayer == null ? null : currentPlayer.clone();\n        return cloned;\n    }\n}\n```\n\n```java\npackage assignment.protocol;\n\nimport java.util.Objects;\nimport java.util.StringJoiner;\n\n/**\n * Move class represent a move made by a {@link Player}, moving a piece from one {@link Place} to another {@link Place}.\n */\npublic class Move implements Cloneable {\n    /**\n     * Source place of the move.\n     */\n    private Place source;\n\n    /**\n     * Move destination\n     */\n    private Place destination;\n\n    public Move(Place source, Place destination) {\n        this.source = source;\n        this.destination = destination;\n    }\n\n    public Move(int sourceX, int sourceY, int destinationX, int destinationY) {\n        this(new Place(sourceX, sourceY), new Place(destinationX, destinationY));\n    }\n\n    public Move(Place source, int destinationX, int destinationY) {\n        this(source, new Place(destinationX, destinationY));\n    }\n\n    /* Getters start */\n    public Place getSource() {\n        return source;\n    }\n\n    public Place getDestination() {\n        return destination;\n    }\n    /* Getters end */\n\n    /* Object methods start */\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Move move = (Move) o;\n        return source.equals(move.source) &&\n                destination.equals(move.destination);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(source, destination);\n    }\n\n    @Override\n    public String toString() {\n        return new StringJoiner(\", \", Move.class.getSimpleName() + \"[\", \"]\")\n                .add(\"source=\" + source)\n                .add(\"destination=\" + destination)\n                .toString();\n    }\n\n    @Override\n    public Move clone() throws CloneNotSupportedException {\n        Move cloned = (Move) super.clone();\n        cloned.source = this.source.clone();\n        cloned.destination = this.destination.clone();\n        return cloned;\n    }\n\n    /* Object methods end */\n\n}\n\n```\n\n```java\npackage assignment.protocol;\n\n\n/**\n * The abstract class that a game piece should extend.\n */\npublic abstract class Piece {\n    /**\n     * The player that owns this piece.\n     */\n    private final Player player;\n\n    public Piece(Player player) {\n        this.player = player;\n    }\n\n    public final Player getPlayer() {\n        return this.player;\n    }\n\n    /**\n     * Returns a char which is used to facilitate output in the console\n     *\n     * @return the label to represent the piece on the board\n     */\n    public abstract char getLabel();\n\n    /**\n     * Returns an array of moves that are valid given the current place of the piece.\n     *\n     * @param game   the game object\n     * @param source the current place of the piece\n     * @return a set of available moves\n     */\n    public abstract Move[] getAvailableMoves(Game game, Place source);\n}\n\n```\n\n```java\npackage assignment.protocol;\n\n/**\n * A square (position, place) in the gameboard.\n * Represented by coordinates a 2-D coordinate system.\n * <p>\n * x and y coordinates of a place on gameboard are two fields of this class.\n */\npublic class Place implements Cloneable {\n    private int x;\n\n    private int y;\n\n    public Place(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    public int x() {\n        return x;\n    }\n\n    public void x(int x) {\n        this.x = x;\n    }\n\n    public int y() {\n        return y;\n    }\n\n    public void y(int y) {\n        this.y = y;\n    }\n\n    @Override\n    publi"}
