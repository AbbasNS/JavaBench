{"task_id": "PA19/Cell.java", "target": "game/map/cells/Cell.java", "code": "```java\npackage game.map.cells;\n\nimport game.MapElement;\nimport game.map.cells.FillableCell;\nimport game.map.cells.TerminationCell;\nimport game.map.cells.Wall;\nimport util.Coordinate;\nimport util.Direction;\n\n/**\n * Representation of a cell in the {@link game.map.Map}.\n */\npublic abstract class Cell implements MapElement {\n\n    public final Coordinate coord;\n\n    /**\n     * @param coord coordination of {@code this} cell\n     */\n    Cell(Coordinate coord) {\n        this.coord = coord;\n    }\n\n    /**\n     * Parses a {@link Cell} from a character.\n     *\n     * <p>\n     * Here is the list of characters to their corresponding map element:\n     * W: Wall\n     * .: Cell\n     * ^: Source/Sink pipe pointing upward\n     * v: Source/Sink pipe pointing downward\n     * <: Source/Sink pipe pointing leftward\n     * >: Source/Sink pipe pointing rightward\n     * If the character does not represent a {@link TerminationCell}, the {@code terminationType} parameter can be ignored.\n     * </p>\n     *\n     * @param c Character to parse. For example, 'W' refers to a wall.\n     * @param coord Coordinate of the newly created cell.\n     * @param terminationType If the character is a termination cell, its type. Otherwise, this argument is ignored and\n     *                        can be null.\n     * @return A cell based on the given creation parameters, or null if the parameters cannot form a valid Cell.\n     */\n    public static Cell fromChar(char c, Coordinate coord, TerminationCell.Type terminationType) {\n        // TODO\n\n        return null;\n    }\n}\n\n```\n", "code_context": "```java\npackage game;\n\npublic interface MapElement {\n\n    char toSingleChar() {\n    }\n}\n\n```\n\n```java\npackage game.map.cells;\n\npublic class FillableCell extends Cell implements MapElement {\n\n    private Pipe pipe;\n\n    public FillableCell(Coordinate coord) {\n    }\n\n    public FillableCell(Coordinate coord, Pipe pipe) {\n    }\n\n    public Optional<Pipe> getPipe() {\n    }\n\n    @Override\n    public char toSingleChar() {\n    }\n\n    public void setPipe(Pipe pipe) {\n    }\n}\n\n```\n\n```java\npackage game.map.cells;\n\npublic class TerminationCell extends Cell {\n\n    private boolean isFilled = false;\n\n    public final Direction pointingTo;\n\n    public final Type type;\n\n    public TerminationCell(Coordinate coord, Direction direction, Type type) {\n    }\n\n    public void setFilled() {\n    }\n\n    @Override\n    public char toSingleChar() {\n    }\n\n    public enum Type {\n\n        SOURCE, SINK\n    }\n\n    public static class CreateInfo {\n\n        public final Coordinate coord;\n\n        public final Direction dir;\n\n        public CreateInfo(Coordinate coord, Direction dir) {\n        }\n    }\n}\n\n```\n\n```java\npackage game.map.cells;\n\npublic class Wall extends Cell {\n\n    public Wall(Coordinate coord) {\n    }\n\n    @Override\n    public char toSingleChar() {\n    }\n}\n\n```\n\n```java\npackage util;\n\npublic class Coordinate {\n\n    public final int row;\n\n    public final int col;\n\n    public Coordinate(int row, int col) {\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n    }\n\n    public boolean equals(Coordinate other) {\n    }\n\n    @Override\n    public int hashCode() {\n    }\n\n    public Coordinate add(Coordinate other) {\n    }\n}\n\n```\n\n```java\npackage util;\n\npublic enum Direction {\n\n    UP, DOWN, LEFT, RIGHT;\n\n    public Direction getOpposite() {\n    }\n\n    public Coordinate getOffset() {\n    }\n}\n\n```\n"}
{"task_id": "PA19/FillableCell.java", "target": "game/map/cells/FillableCell.java", "code": "```java\npackage game.map.cells;\n\nimport game.MapElement;\nimport game.map.cells.Cell;\nimport game.pipes.Pipe;\nimport util.Coordinate;\n\nimport java.io.*;\nimport java.util.*;\n\n/**\n * Represents a {@link Cell} which can contain a pipe.\n */\npublic class FillableCell extends Cell implements MapElement {\n\n    private Pipe pipe;\n\n    /**\n     * Constructs a {@link FillableCell}.\n     *\n     * @param coord Coordinate where the cell resides in the map.\n     */\n    public FillableCell(Coordinate coord) {\n        super(coord);\n        pipe = null;\n    }\n\n    /**\n     * Constructs a {@link FillableCell} with a pipe already contained in it.\n     *\n     * @param coord Coordinate where the cell resides in the map.\n     * @param pipe The pipe inside this cell.\n     */\n    public FillableCell(Coordinate coord, Pipe pipe) {\n        super(coord);\n        pipe = null;\n    }\n\n    /**\n     * @return An {@link java.util.Optional} representing the pipe in this tile.\n     */\n    public Optional<Pipe> getPipe() {\n        // TODO\n        return null;\n    }\n\n    /**\n     * @return The character representation of the pipe, or {@code '.'} if the cell is empty.\n     */\n    @Override\n    public char toSingleChar() {\n        // TODO\n        return '\\0';\n    }\n\n    public void setPipe(Pipe pipe) {\n        this.pipe = pipe;\n    }\n}\n\n```\n", "code_context": "```java\npackage game;\n\npublic interface MapElement {\n\n    char toSingleChar() {\n    }\n}\n\n```\n\n```java\npackage game.map.cells;\n\npublic abstract class Cell implements MapElement {\n\n    public final Coordinate coord;\n\n    Cell(Coordinate coord) {\n    }\n\n    public static Cell fromChar(char c, Coordinate coord, TerminationCell.Type terminationType) {\n    }\n}\n\n```\n\n```java\npackage game.pipes;\n\npublic class Pipe implements MapElement {\n\n    private final Shape shape;\n\n    private boolean filled = false;\n\n    public Pipe(Shape shape) {\n    }\n\n    public void setFilled() {\n    }\n\n    public boolean getFilled() {\n    }\n\n    public Direction[] getConnections() {\n    }\n\n    @Override\n    public char toSingleChar() {\n    }\n\n    public static Pipe fromString(String rep) {\n    }\n\n    public enum Shape {\n\n        HORIZONTAL(PipePatterns.Filled.HORIZONTAL, PipePatterns.Unfilled.HORIZONTAL),\n        VERTICAL(PipePatterns.Filled.VERTICAL, PipePatterns.Unfilled.VERTICAL),\n        TOP_LEFT(PipePatterns.Filled.TOP_LEFT, PipePatterns.Unfilled.TOP_LEFT),\n        TOP_RIGHT(PipePatterns.Filled.TOP_RIGHT, PipePatterns.Unfilled.TOP_RIGHT),\n        BOTTOM_LEFT(PipePatterns.Filled.BOTTOM_LEFT, PipePatterns.Unfilled.BOTTOM_LEFT),\n        BOTTOM_RIGHT(PipePatterns.Filled.BOTTOM_RIGHT, PipePatterns.Unfilled.BOTTOM_RIGHT),\n        CROSS(PipePatterns.Filled.CROSS, PipePatterns.Unfilled.CROSS);\n\n        final char filledChar;\n\n        final char unfilledChar;\n\n        Shape(char filled, char unfilled) {\n        }\n\n        char getCharByState(boolean isFilled) {\n        }\n    }\n}\n\n```\n\n```java\npackage util;\n\npublic class Coordinate {\n\n    public final int row;\n\n    public final int col;\n\n    public Coordinate(int row, int col) {\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n    }\n\n    public boolean equals(Coordinate other) {\n    }\n\n    @Override\n    public int hashCode() {\n    }\n\n    public Coordinate add(Coordinate other) {\n    }\n}\n\n```\n"}
{"task_id": "PA19/TerminationCell.java", "target": "game/map/cells/TerminationCell.java", "code": "```java\npackage game.map.cells;\n\nimport game.map.cells.Cell;\nimport util.Coordinate;\nimport util.Direction;\nimport util.PipePatterns;\n\n/**\n * Represents a source or a sink {@link Cell}.\n */\npublic class TerminationCell extends Cell {\n\n    private boolean isFilled = false;\n    public final Direction pointingTo;\n    public final Type type;\n\n    /**\n     *\n     * @param coord coordination of this cell\n     * @param direction direction of this termination\n     * @param type type of this termination\n     */\n    public TerminationCell(Coordinate coord, Direction direction, Type type) {\n        // TODO\n    }\n\n    /**\n     * Sets this cell as filled.\n     */\n    public void setFilled() {\n        // TODO\n    }\n\n    /**\n     * <p>\n     * Hint: use {@link util.PipePatterns}\n     * </p>\n     *\n     * @return the character representation of a termination cell in game\n     */\n    @Override\n    public char toSingleChar() {\n        // TODO\n        return '\\0';\n    }\n\n    public enum Type {\n        SOURCE, SINK\n    }\n\n    /**\n     * Data class encapsulating the coordinate and direction of the {@link TerminationCell}.\n     */\n    public static class CreateInfo {\n\n        public final Coordinate coord;\n        public final Direction dir;\n\n        public CreateInfo(Coordinate coord, Direction dir) {\n            this.coord = coord;\n            this.dir = dir;\n        }\n    }\n}\n\n```\n", "code_context": "```java\npackage game.map.cells;\n\npublic abstract class Cell implements MapElement {\n\n    public final Coordinate coord;\n\n    Cell(Coordinate coord) {\n    }\n\n    public static Cell fromChar(char c, Coordinate coord, TerminationCell.Type terminationType) {\n    }\n}\n\n```\n\n```java\npackage util;\n\npublic class Coordinate {\n\n    public final int row;\n\n    public final int col;\n\n    public Coordinate(int row, int col) {\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n    }\n\n    public boolean equals(Coordinate other) {\n    }\n\n    @Override\n    public int hashCode() {\n    }\n\n    public Coordinate add(Coordinate other) {\n    }\n}\n\n```\n\n```java\npackage util;\n\npublic enum Direction {\n\n    UP, DOWN, LEFT, RIGHT;\n\n    public Direction getOpposite() {\n    }\n\n    public Coordinate getOffset() {\n    }\n}\n\n```\n\n```java\npackage util;\n\npublic final class PipePatterns {\n\n    private PipePatterns() {\n    }\n\n    public static final char WALL = '\\u2588';\n\n    public static class Filled {\n\n        public static final char UP_ARROW = '\\u25B2';\n\n        public static final char DOWN_ARROW = '\\u25BC';\n\n        public static final char LEFT_ARROW = '\\u25C0';\n\n        public static final char RIGHT_ARROW = '\\u25B6';\n\n        public static final char HORIZONTAL = '\\u2501';\n\n        public static final char VERTICAL = '\\u2503';\n\n        public static final char TOP_LEFT = '\\u251B';\n\n        public static final char TOP_RIGHT = '\\u2517';\n\n        public static final char BOTTOM_LEFT = '\\u2513';\n\n        public static final char BOTTOM_RIGHT = '\\u250F';\n\n        public static final char CROSS = '\\u254B';\n    }\n\n    public static class Unfilled {\n\n        public static final char UP_ARROW = '\\u25B3';\n\n        public static final char DOWN_ARROW = '\\u25BD';\n\n        public static final char LEFT_ARROW = '\\u25C1';\n\n        public static final char RIGHT_ARROW = '\\u25B7';\n\n        public static final char HORIZONTAL = '\\u2550';\n\n        public static final char VERTICAL = '\\u2551';\n\n        public static final char TOP_LEFT = '\\u255D';\n\n        public static final char TOP_RIGHT = '\\u255A';\n\n        public static final char BOTTOM_LEFT = '\\u2557';\n\n        public static final char BOTTOM_RIGHT = '\\u2554';\n\n        public static final char CROSS = '\\u256C';\n    }\n}\n\n```\n"}
{"task_id": "PA19/Wall.java", "target": "game/map/cells/Wall.java", "code": "```java\npackage game.map.cells;\n\nimport game.map.cells.Cell;\nimport util.Coordinate;\nimport util.PipePatterns;\n\n/**\n * Represents a wall in {@link game.map.Map}.\n */\npublic class Wall extends Cell {\n\n    /**\n     * @param coord coordination of {@code this} cell\n     */\n    public Wall(Coordinate coord) {\n        // TODO\n    }\n\n    /**\n     * <p>\n     * Hint: use {@link util.PipePatterns}\n     * </p>\n     *\n     * @return the character representation of a wall in game\n     */\n    @Override\n    public char toSingleChar() {\n        // TODO\n        return '\\0';\n    }\n}\n\n```\n", "code_context": "```java\npackage game.map.cells;\n\npublic abstract class Cell implements MapElement {\n\n    public final Coordinate coord;\n\n    Cell(Coordinate coord) {\n    }\n\n    public static Cell fromChar(char c, Coordinate coord, TerminationCell.Type terminationType) {\n    }\n}\n\n```\n\n```java\npackage util;\n\npublic class Coordinate {\n\n    public final int row;\n\n    public final int col;\n\n    public Coordinate(int row, int col) {\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n    }\n\n    public boolean equals(Coordinate other) {\n    }\n\n    @Override\n    public int hashCode() {\n    }\n\n    public Coordinate add(Coordinate other) {\n    }\n}\n\n```\n\n```java\npackage util;\n\npublic final class PipePatterns {\n\n    private PipePatterns() {\n    }\n\n    public static final char WALL = '\\u2588';\n\n    public static class Filled {\n\n        public static final char UP_ARROW = '\\u25B2';\n\n        public static final char DOWN_ARROW = '\\u25BC';\n\n        public static final char LEFT_ARROW = '\\u25C0';\n\n        public static final char RIGHT_ARROW = '\\u25B6';\n\n        public static final char HORIZONTAL = '\\u2501';\n\n        public static final char VERTICAL = '\\u2503';\n\n        public static final char TOP_LEFT = '\\u251B';\n\n        public static final char TOP_RIGHT = '\\u2517';\n\n        public static final char BOTTOM_LEFT = '\\u2513';\n\n        public static final char BOTTOM_RIGHT = '\\u250F';\n\n        public static final char CROSS = '\\u254B';\n    }\n\n    public static class Unfilled {\n\n        public static final char UP_ARROW = '\\u25B3';\n\n        public static final char DOWN_ARROW = '\\u25BD';\n\n        public static final char LEFT_ARROW = '\\u25C1';\n\n        public static final char RIGHT_ARROW = '\\u25B7';\n\n        public static final char HORIZONTAL = '\\u2550';\n\n        public static final char VERTICAL = '\\u2551';\n\n        public static final char TOP_LEFT = '\\u255D';\n\n        public static final char TOP_RIGHT = '\\u255A';\n\n        public static final char BOTTOM_LEFT = '\\u2557';\n\n        public static final char BOTTOM_RIGHT = '\\u2554';\n\n        public static final char CROSS = '\\u256C';\n    }\n}\n\n```\n"}
{"task_id": "PA19/Map.java", "target": "game/map/Map.java", "code": "```java\npackage game.map;\n\nimport game.map.cells.Cell;\nimport game.map.cells.FillableCell;\nimport game.map.cells.TerminationCell;\nimport game.map.cells.Wall;\nimport game.pipes.Pipe;\nimport io.Deserializer;\nimport util.Coordinate;\nimport util.Direction;\nimport util.StringUtils;\n\nimport java.io.*;\nimport java.util.*;\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\nimport java.util.stream.Stream;\n\n/**\n * Map of the game.\n */\npublic class Map {\n\n    private final int rows;\n    private final int cols;\n    public final Cell[][] cells;\n\n    private TerminationCell sourceCell;\n    private TerminationCell sinkCell;\n\n\n    /**\n     * You can use this variable to implement the {@link Map#fillTiles} method, but it is not necessary\n     */\n    private final Set<Coordinate> filledTiles = new HashSet<>();\n    /**\n     * You can use this variable to implement the {@link Map#fillTiles} method, but it is not necessary\n     */\n    private int prevFilledTiles = 0;\n    /**\n     * You can use this variable to implement the {@link Map#fillTiles} method, but it is not necessary\n     */\n    private Integer prevFilledDistance;\n\n    /**\n     * Creates a map with size of rows x cols.\n     *\n     * <p>\n     * The map should only contain one source tile in any non-edge cell.\n     * The map should only contain one sink tile in any edge cell.\n     * The source tile must not point into a wall.\n     * The sink tile must point outside the map.\n     * </p>\n     *\n     * @param rows Number of rows.\n     * @param cols Number of columns.\n     */\n    public Map(int rows, int cols) {\n        // TODO\n    }\n\n    /**\n     * Creates a map with the given cells.\n     *\n     * <p>\n     * The map should only contain one source tile in any non-edge cell.\n     * The map should only contain one sink tile in any edge cell.\n     * The source tile must not point into a wall.\n     * The sink tile must point outside the map.\n     * </p>\n     *\n     * @param rows  Number of rows.\n     * @param cols  Number of columns.\n     * @param cells Cells to fill the map.\n     */\n    public Map(int rows, int cols, Cell[][] cells) {\n        // TODO\n    }\n\n    /**\n     * Constructs a map from a map string.\n     * <p>\n     * This is a convenience method for unit testing.\n     * </p>\n     *\n     * @param rows     Number of rows.\n     * @param cols     Number of columns.\n     * @param cellsRep String representation of the map, with columns delimited by {@code '\\n'}.\n     * @return A map with the cells set from {@code cellsRep}.\n     * @throws IllegalArgumentException If the map is incorrectly formatted.\n     */\n    static Map fromString(int rows, int cols, String cellsRep) {\n        Cell[][] cells = Deserializer.parseString(rows, cols, cellsRep);\n\n        return new Map(rows, cols, cells);\n    }\n\n    /**\n     * Tries to place a pipe at (row, col).\n     *\n     * @param coord Coordinate to place pipe at.\n     * @param pipe  Pipe to place in cell.\n     * @return {@code true} if the pipe is placed in the cell, {@code false} otherwise.\n     */\n    public boolean tryPlacePipe(final Coordinate coord, final Pipe pipe) {\n        return tryPlacePipe(coord.row, coord.col, pipe);\n    }\n\n    /**\n     * Tries to place a pipe at (row, col).\n     *\n     * <p>\n     * Note: You cannot overwrite the pipe of a cell once the cell is occupied.\n     * </p>\n     * <p>\n     * Hint: Remember to check whether the map coordinates are within bounds, and whether the target cell is a \n     * {@link FillableCell}.\n     * </p>\n     *\n     * @param row One-Based row number to place pipe at.\n     * @param col One-Based column number to place pipe at.\n     * @param p   Pipe to place in cell.\n     * @return {@code true} if the pipe is placed in the cell, {@code false} otherwise.\n     */\n    boolean tryPlacePipe(int row, int col, Pipe p) {\n        // TODO\n    }\n\n    /**\n     * Displays the current map.\n     */\n    public void display() {\n        final int padLength = Integer.valueOf(rows - 1).toString().length();\n\n        Runnable printColumns = () -> {\n            System.out.print(StringUtils.createPadding(padLength, ' '));\n            System.out.print(' ');\n            for (int i = 0; i < cols - 2; ++i) {\n                System.out.print((char) ('A' + i));\n            }\n            System.out.println();\n        };\n\n        printColumns.run();\n\n        for (int i = 0; i < rows; ++i) {\n            if (i != 0 && i != rows - 1) {\n                System.out.print(String.format(\"%1$\" + padLength + \"s\", i));\n            } else {\n                System.out.print(StringUtils.createPadding(padLength, ' '));\n            }\n\n            Arrays.stream(cells[i]).forEachOrdered(elem -> System.out.print(elem.toSingleChar()));\n\n            if (i != 0 && i != rows - 1) {\n                System.out.print(i);\n            }\n\n            System.out.println();\n        }\n\n        printColumns.run();\n    }\n\n    /**\n     * Undoes a step from the map.\n     *\n     * <p>\n     * Effectively replaces the cell with an empty cell in the coordinate specified.\n     * </p>\n     *\n     * @param coord Coordinate to reset.\n     * @throws IllegalArgumentException if the cell is not an instance of {@link FillableCell}.\n     */\n    public void undo(final Coordinate coord) {\n        // TODO\n    }\n\n    /**\n     * Fills the source cell.\n     */\n    public void fillBeginTile() {\n        sourceCell.setFilled();\n    }\n\n    /**\n     * Fills all pipes that are within {@code distance} units from the {@code sourceCell}.\n     * \n     * <p>\n     * Hint: There are two ways to approach this. You can either iteratively fill the tiles by distance (i.e. filling \n     * distance=0, distance=1, etc), or you can save the tiles you have already filled, and fill all adjacent cells of \n     * the already-filled tiles. Whichever method you choose is up to you, as long as the result is the same.\n     * </p>\n     *\n     * @param distance Distance to fill pipes.\n     */\n    public void fillTiles(int distance) {\n        // TODO\n    }\n\n    /**\n     * Checks whether there exists a path from {@code sourceCell} to {@code sinkCell}.\n     * \n     * <p>\n     * The game is won when the player must place pipes on the map such that a path is formed from the source tile to the sink tile. One of the approaches to check this is to use Breadth First Search to search for the sink tile along the pipes. You may also use other algorithms or create your own, provided it achieves the same goal.\n     * The game is lost when no additional pipes are filled in each round after the Nth round. The value of N' can be configured in the loaded map. In the example maps, N` is set to 10.\n     * </p>\n     *\n     * @return {@code true} if a path exists, else {@code false}.\n     */\n    public boolean checkPath() {\n        // TODO\n        return false;\n    }\n\n    /**\n     * <p>\n     * Hint: The game is lost when a round ends and no pipes are filled during the round. Is\n     * there a way to check whether pipes are filled during a round?\n     * </p>\n     *\n     * @return {@code true} if the game is lost.\n     */\n    public boolean hasLost() {\n        // TODO\n        return false;\n    }\n}\n\n```\n", "code_context": "```java\npackage game.map.cells;\n\npublic abstract class Cell implements MapElement {\n\n    public final Coordinate coord;\n\n    Cell(Coordinate coord) {\n    }\n\n    public static Cell fromChar(char c, Coordinate coord, TerminationCell.Type terminationType) {\n    }\n}\n\n```\n\n```java\npackage game.map.cells;\n\npublic class FillableCell extends Cell implements MapElement {\n\n    private Pipe pipe;\n\n    public FillableCell(Coordinate coord) {\n    }\n\n    public FillableCell(Coordinate coord, Pipe pipe) {\n    }\n\n    public Optional<Pipe> getPipe() {\n    }\n\n    @Override\n    public char toSingleChar() {\n    }\n\n    public void setPipe(Pipe pipe) {\n    }\n}\n\n```\n\n```java\npackage game.map.cells;\n\npublic class TerminationCell extends Cell {\n\n    private boolean isFilled = false;\n\n    public final Direction pointingTo;\n\n    public final Type type;\n\n    public TerminationCell(Coordinate coord, Direction direction, Type type) {\n    }\n\n    public void setFilled() {\n    }\n\n    @Override\n    public char toSingleChar() {\n    }\n\n    public enum Type {\n\n        SOURCE, SINK\n    }\n\n    public static class CreateInfo {\n\n        public final Coordinate coord;\n\n        public final Direction dir;\n\n        public CreateInfo(Coordinate coord, Direction dir) {\n        }\n    }\n}\n\n```\n\n```java\npackage game.map.cells;\n\npublic class Wall extends Cell {\n\n    public Wall(Coordinate coord) {\n    }\n\n    @Override\n    public char toSingleChar() {\n    }\n}\n\n```\n\n```java\npackage game.pipes;\n\npublic class Pipe implements MapElement {\n\n    private final Shape shape;\n\n    private boolean filled = false;\n\n    public Pipe(Shape shape) {\n    }\n\n    public void setFilled() {\n    }\n\n    public boolean getFilled() {\n    }\n\n    public Direction[] getConnections() {\n    }\n\n    @Override\n    public char toSingleChar() {\n    }\n\n    public static Pipe fromString(String rep) {\n    }\n\n    public enum Shape {\n\n        HORIZONTAL(PipePatterns.Filled.HORIZONTAL, PipePatterns.Unfilled.HORIZONTAL),\n        VERTICAL(PipePatterns.Filled.VERTICAL, PipePatterns.Unfilled.VERTICAL),\n        TOP_LEFT(PipePatterns.Filled.TOP_LEFT, PipePatterns.Unfilled.TOP_LEFT),\n        TOP_RIGHT(PipePatterns.Filled.TOP_RIGHT, PipePatterns.Unfilled.TOP_RIGHT),\n        BOTTOM_LEFT(PipePatterns.Filled.BOTTOM_LEFT, PipePatterns.Unfilled.BOTTOM_LEFT),\n        BOTTOM_RIGHT(PipePatterns.Filled.BOTTOM_RIGHT, PipePatterns.Unfilled.BOTTOM_RIGHT),\n        CROSS(PipePatterns.Filled.CROSS, PipePatterns.Unfilled.CROSS);\n\n        final char filledChar;\n\n        final char unfilledChar;\n\n        Shape(char filled, char unfilled) {\n        }\n\n        char getCharByState(boolean isFilled) {\n        }\n    }\n}\n\n```\n\n```java\npackage io;\n\npublic class Deserializer {\n\n    private Path path;\n\n    public Deserializer(final String path) throws FileNotFoundException {\n    }\n\n    private Deserializer(final Path path) throws FileNotFoundException {\n    }\n\n    public Game parseGame() {\n    }\n\n    public static Cell[][] parseString(final int rows, final int cols, final String cellsRep) {\n    }\n\n    private String getFirstNonEmptyLine(final BufferedReader br) throws IOException {\n    }\n}\n\n```\n\n```java\npackage util;\n\npublic class Coordinate {\n\n    public final int row;\n\n    public final int col;\n\n    public Coordinate(int row, int col) {\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n    }\n\n    public boolean equals(Coordinate other) {\n    }\n\n    @Override\n    public int hashCode() {\n    }\n\n    public Coordinate add(Coordinate other) {\n    }\n}\n\n```\n\n```java\npackage util;\n\npublic enum Direction {\n\n    UP, DOWN, LEFT, RIGHT;\n\n    public Direction getOpposite() {\n    }\n\n    public Coordinate getOffset() {\n    }\n}\n\n```\n\n```java\npackage util;\n\npublic class StringUtils {\n\n    private StringUtils() {\n    }\n\n    public static String createPadding(int count, char ch) {\n    }\n}\n\n```\n"}
{"task_id": "PA19/Pipe.java", "target": "game/pipes/Pipe.java", "code": "```java\npackage game.pipes;\n\nimport game.MapElement;\nimport util.Direction;\nimport util.PipePatterns;\n\npublic class Pipe implements MapElement {\n\n    private final Shape shape;\n    private boolean filled = false;\n\n    /**\n     * Creates a new pipe with a given shape.\n     *\n     * @param shape Shape of the pipe.\n     */\n    public Pipe(Shape shape) {\n        // TODO\n    }\n\n    /**\n     * Sets the pipe as filled.\n     */\n    public void setFilled() {\n        // TODO\n    }\n\n    /**\n     * @return Whether this pipe is filled.\n     */\n    public boolean getFilled() {\n        // TODO\n        return false;\n    }\n\n    /**\n     * @return List of connections for this pipe.\n     * @throws IllegalStateException if {@code this} pipe cannot be identified.\n     */\n    public Direction[] getConnections() {\n        // TODO\n    }\n\n    /**\n     * @return The character representation of this pipe. Note that the representation is different for filled and\n     * unfilled pipes.\n     */\n    @Override\n    public char toSingleChar() {\n        // TODO\n    }\n\n    /**\n     * Converts a String to a Pipe.\n     *\n     * <p>\n     * Here is the list of ASCII representation to the pipes:\n     * TL: Top-Left (\u255d)\n     * TR: Top-Right (\u255a)\n     * BL: Bottom-Left (\u2557)\n     * BR: Bottom-Right (\u2554)\n     * HZ: Horizontal (\u2550)\n     * VT: Vertical (\u2551)\n     * CR: Cross (\u256c)\n     * </p>\n     *\n     * @param rep String representation of the pipe. For example, \"HZ\" corresponds to a pipe of horizontal shape.\n     * @return Pipe identified by the string.\n     * @throws IllegalArgumentException if the String does not represent a known pipe.\n     */\n    public static Pipe fromString(String rep) {\n        // TODO\n    }\n\n    public enum Shape {\n        HORIZONTAL(PipePatterns.Filled.HORIZONTAL, PipePatterns.Unfilled.HORIZONTAL),\n        VERTICAL(PipePatterns.Filled.VERTICAL, PipePatterns.Unfilled.VERTICAL),\n        TOP_LEFT(PipePatterns.Filled.TOP_LEFT, PipePatterns.Unfilled.TOP_LEFT),\n        TOP_RIGHT(PipePatterns.Filled.TOP_RIGHT, PipePatterns.Unfilled.TOP_RIGHT),\n        BOTTOM_LEFT(PipePatterns.Filled.BOTTOM_LEFT, PipePatterns.Unfilled.BOTTOM_LEFT),\n        BOTTOM_RIGHT(PipePatterns.Filled.BOTTOM_RIGHT, PipePatterns.Unfilled.BOTTOM_RIGHT),\n        CROSS(PipePatterns.Filled.CROSS, PipePatterns.Unfilled.CROSS);\n\n        final char filledChar;\n        final char unfilledChar;\n\n        /**\n         *\n         * @param filled Representation of {@code this} shape when filled\n         * @param unfilled Representation of {@code this} shape when unfilled\n         */\n        Shape(char filled, char unfilled) {\n            this.filledChar = filled;\n            this.unfilledChar = unfilled;\n        }\n\n        /**\n         *\n         * @param isFilled The filling state of {@code this} shape\n         * @return The character representation of {@code this} shape according to the filling state\n         */\n        char getCharByState(boolean isFilled) {\n            // TODO\n            return '\\0';\n        }\n    }\n}\n\n```\n", "code_context": "```java\npackage game;\n\npublic interface MapElement {\n\n    char toSingleChar() {\n    }\n}\n\n```\n\n```java\npackage util;\n\npublic enum Direction {\n\n    UP, DOWN, LEFT, RIGHT;\n\n    public Direction getOpposite() {\n    }\n\n    public Coordinate getOffset() {\n    }\n}\n\n```\n\n```java\npackage util;\n\npublic final class PipePatterns {\n\n    private PipePatterns() {\n    }\n\n    public static final char WALL = '\\u2588';\n\n    public static class Filled {\n\n        public static final char UP_ARROW = '\\u25B2';\n\n        public static final char DOWN_ARROW = '\\u25BC';\n\n        public static final char LEFT_ARROW = '\\u25C0';\n\n        public static final char RIGHT_ARROW = '\\u25B6';\n\n        public static final char HORIZONTAL = '\\u2501';\n\n        public static final char VERTICAL = '\\u2503';\n\n        public static final char TOP_LEFT = '\\u251B';\n\n        public static final char TOP_RIGHT = '\\u2517';\n\n        public static final char BOTTOM_LEFT = '\\u2513';\n\n        public static final char BOTTOM_RIGHT = '\\u250F';\n\n        public static final char CROSS = '\\u254B';\n    }\n\n    public static class Unfilled {\n\n        public static final char UP_ARROW = '\\u25B3';\n\n        public static final char DOWN_ARROW = '\\u25BD';\n\n        public static final char LEFT_ARROW = '\\u25C1';\n\n        public static final char RIGHT_ARROW = '\\u25B7';\n\n        public static final char HORIZONTAL = '\\u2550';\n\n        public static final char VERTICAL = '\\u2551';\n\n        public static final char TOP_LEFT = '\\u255D';\n\n        public static final char TOP_RIGHT = '\\u255A';\n\n        public static final char BOTTOM_LEFT = '\\u2557';\n\n        public static final char BOTTOM_RIGHT = '\\u2554';\n\n        public static final char CROSS = '\\u256C';\n    }\n}\n\n```\n"}
{"task_id": "PA19/CellStack.java", "target": "game/CellStack.java", "code": "```java\npackage game;\n\nimport game.map.cells.FillableCell;\n\nimport java.io.*;\nimport java.util.*;\n\n/**\n * Class encapsulating an undo stack.\n */\npublic class CellStack {\n\n    private final Stack<FillableCell> cellStack = new Stack<>();\n    private int count = 0;\n\n    /**\n     * Pushes a cell into the stack.\n     *\n     * @param cell Cell to push into the stack.\n     */\n    void push(final FillableCell cell) {\n        // TODO\n    }\n\n    /**\n     * Pops a cell from the stack.\n     *\n     * @return The last-pushed cell, or {@code null} if the stack is empty.\n     */\n    FillableCell pop() {\n        // TODO\n    }\n\n    /**\n     * @return Number of undos (i.e. {@link CellStack#pop()}) invoked.\n     */\n    int getUndoCount() {\n        // TODO\n        return 0;\n    }\n\n    /**\n     * Displays the current undo count to {@link System#out}.\n     */\n    void display() {\n        System.out.println(\"Undo Count: \" + count);\n    }\n}\n\n```\n", "code_context": "```java\npackage game.map.cells;\n\npublic class FillableCell extends Cell implements MapElement {\n\n    private Pipe pipe;\n\n    public FillableCell(Coordinate coord) {\n    }\n\n    public FillableCell(Coordinate coord, Pipe pipe) {\n    }\n\n    public Optional<Pipe> getPipe() {\n    }\n\n    @Override\n    public char toSingleChar() {\n    }\n\n    public void setPipe(Pipe pipe) {\n    }\n}\n\n```\n"}
{"task_id": "PA19/DelayBar.java", "target": "game/DelayBar.java", "code": "```java\npackage game;\n\nimport util.StringUtils;\n\nimport java.io.*;\n\n/**\n * Class representing the delay before the water starts to flow in the map.\n */\npublic class DelayBar {\n\n    private final int initialValue;\n    private int currentValue;\n\n    /**\n     * Constructs a {@link DelayBar}.\n     *\n     * @param initialValue Number of rounds to wait before the water starts to flow.\n     */\n    DelayBar(int initialValue) {\n        this.initialValue = initialValue;\n        this.currentValue = initialValue;\n    }\n\n    /**\n     * Decrements the current value by 1.\n     */\n    void countdown() {\n        // TODO\n    }\n\n    /**\n     * <p>\n     * Hint: The value of {@code currentValue} will roll into negative once the delay ends. You may use the absolute\n     * value of this number to compute the number of valid moves since the delay has ended.\n     * </p>\n     *\n     * @return The distance the water should flow at this stage.\n     */\n    int distance() {\n        // TODO\n        return 0;\n    }\n\n    void display() {\n        if (currentValue > 0) {\n            System.out.print(\"Rounds Countdown: \");\n            System.out.print(StringUtils.createPadding(currentValue, '='));\n            System.out.print(StringUtils.createPadding(initialValue - currentValue, ' '));\n            System.out.print(\" \" + currentValue);\n            System.out.println();\n        } else {\n            System.out.println();\n        }\n    }\n}\n\n```\n", "code_context": "```java\npackage util;\n\npublic class StringUtils {\n\n    private StringUtils() {\n    }\n\n    public static String createPadding(int count, char ch) {\n    }\n}\n\n```\n"}
{"task_id": "PA19/Game.java", "target": "game/Game.java", "code": "```java\npackage game;\n\nimport game.map.Map;\nimport game.map.cells.Cell;\nimport game.map.cells.FillableCell;\nimport game.pipes.Pipe;\nimport io.Deserializer;\nimport util.Coordinate;\nimport game.DelayBar;\nimport game.CellStack;\nimport game.PipeQueue;\n\nimport java.util.*;\nimport java.io.*;\n\npublic class Game {\n\n    private final Map map;\n    private final PipeQueue pipeQueue;\n    private final DelayBar delayBar;\n    private final CellStack cellStack = new CellStack();\n\n    private int numOfSteps = 0;\n\n    /**\n     * Creates a game with a map of rows x cols.\n     *\n     * @param rows Number of rows to generate, not counting the surrounding walls.\n     * @param cols Number of columns to generate, not counting the surrounding walls.\n     */\n    public Game(int rows, int cols) {\n        // TODO\n    }\n\n    /**\n     * Creates a game with a given map and various properties.\n     *\n     * @param rows Number of rows of the given map.\n     * @param cols Number of columns of the given map.\n     * @param delay Delay in number of rounds before filling the pipes.\n     * @param cells Cells of the map.\n     * @param pipes List of pre-generated pipes, if any.\n     */\n    public Game(int rows, int cols, int delay, Cell[][] cells, List<Pipe> pipes) {\n        // TODO\n    }\n\n    /**\n     * Creates a game with a given map and various properties.\n     *\n     * <p>\n     * This constructor is a convenience method for unit testing purposes.\n     * </p>\n     *\n     * @param rows Number of rows of the given map.\n     * @param cols Number of columns of the given map.\n     * @param delay Delay in number of rounds before filling the pipes.\n     * @param cellsRep String representation of the map, with columns delimited by {@code '\\n'}.\n     * @param pipes List of pre-generated pipes, if any.\n     * @return A game constructed with the given parameters.\n     */\n    static Game fromString(int rows, int cols, int delay, String cellsRep, List<Pipe> pipes) {\n        Cell[][] cells = Deserializer.parseString(rows, cols, cellsRep);\n\n        return new Game(rows, cols, delay, cells, pipes);\n    }\n\n    /**\n     * Places a pipe at (row, col).\n     *\n     * <p>\n     * This method should convert the row and column into {@link Coordinate} and try to place the pipe on the map. If\n     * this succeeds, also update the pipe queue, delay bar, cell stack, and the number of steps.\n     * </p>\n     *\n     * @param row Row number, 1-based.\n     * @param col Column character.\n     * @return {@code true} if the pipe is placed.\n     */\n    public boolean placePipe(int row, char col) {\n        // TODO\n    }\n\n    /**\n     * Directly skips the current pipe and use the next pipe.\n     */\n    public void skipPipe() {\n        // TODO\n    }\n\n    /**\n     * Undos a step from the game.\n     *\n     * <p>\n     * Note: Undoing a step counts will increment the number of steps by one.\n     * </p>\n     * <p>\n     * Hint: Remember to check whether there are cells to undo.\n     * </p>\n     *\n     * @return {@code false} if there are no steps to undo, otherwise {@code true}.\n     */\n    public boolean undoStep() {\n        // TODO\n    }\n\n    /**\n     * Displays the current game state.\n     */\n    public void display() {\n        map.display();\n        System.out.println();\n        pipeQueue.display();\n        cellStack.display();\n        System.out.println();\n        delayBar.display();\n    }\n\n    /**\n     * Updates the game state. More specifically, it fills pipes according to the distance the water should flow.\n     *\n     * <p>\n     * This method should invoke {@link Map#fillTiles(int)} up to a certain distance.\n     * </p>\n     */\n    public void updateState() {\n        // TODO\n    }\n\n    /**\n     * Checks whether the game is won.\n     *\n     * @return {@code true} if the game is won.\n     */\n    public boolean hasWon() {\n        // TODO\n        return false;\n    }\n\n    /**\n     * Checks whether the game is lost.\n     *\n     * <p>\n     * Hint: This method should invoke {@link Map#hasLost()}. You may also need other judgements.\n     * </p>\n     *\n     * @return {@code true} if the game is lost.\n     */\n    public boolean hasLost() {\n        // TODO\n        return false;\n    }\n\n    /**\n     * @return Number of steps the player has taken.\n     */\n    public int getNumOfSteps() {\n        // TODO\n        return 0;\n    }\n}\n\n```\n", "code_context": "```java\npackage game.map.cells;\n\npublic abstract class Cell implements MapElement {\n\n    public final Coordinate coord;\n\n    Cell(Coordinate coord) {\n    }\n\n    public static Cell fromChar(char c, Coordinate coord, TerminationCell.Type terminationType) {\n    }\n}\n\n```\n\n```java\npackage game.map.cells;\n\npublic class FillableCell extends Cell implements MapElement {\n\n    private Pipe pipe;\n\n    public FillableCell(Coordinate coord) {\n    }\n\n    public FillableCell(Coordinate coord, Pipe pipe) {\n    }\n\n    public Optional<Pipe> getPipe() {\n    }\n\n    @Override\n    public char toSingleChar() {\n    }\n\n    public void setPipe(Pipe pipe) {\n    }\n}\n\n```\n\n```java\npackage game.pipes;\n\npublic class Pipe implements MapElement {\n\n    private final Shape shape;\n\n    private boolean filled = false;\n\n    public Pipe(Shape shape) {\n    }\n\n    public void setFilled() {\n    }\n\n    public boolean getFilled() {\n    }\n\n    public Direction[] getConnections() {\n    }\n\n    @Override\n    public char toSingleChar() {\n    }\n\n    public static Pipe fromString(String rep) {\n    }\n\n    public enum Shape {\n\n        HORIZONTAL(PipePatterns.Filled.HORIZONTAL, PipePatterns.Unfilled.HORIZONTAL),\n        VERTICAL(PipePatterns.Filled.VERTICAL, PipePatterns.Unfilled.VERTICAL),\n        TOP_LEFT(PipePatterns.Filled.TOP_LEFT, PipePatterns.Unfilled.TOP_LEFT),\n        TOP_RIGHT(PipePatterns.Filled.TOP_RIGHT, PipePatterns.Unfilled.TOP_RIGHT),\n        BOTTOM_LEFT(PipePatterns.Filled.BOTTOM_LEFT, PipePatterns.Unfilled.BOTTOM_LEFT),\n        BOTTOM_RIGHT(PipePatterns.Filled.BOTTOM_RIGHT, PipePatterns.Unfilled.BOTTOM_RIGHT),\n        CROSS(PipePatterns.Filled.CROSS, PipePatterns.Unfilled.CROSS);\n\n        final char filledChar;\n\n        final char unfilledChar;\n\n        Shape(char filled, char unfilled) {\n        }\n\n        char getCharByState(boolean isFilled) {\n        }\n    }\n}\n\n```\n\n```java\npackage io;\n\npublic class Deserializer {\n\n    private Path path;\n\n    public Deserializer(final String path) throws FileNotFoundException {\n    }\n\n    private Deserializer(final Path path) throws FileNotFoundException {\n    }\n\n    public Game parseGame() {\n    }\n\n    public static Cell[][] parseString(final int rows, final int cols, final String cellsRep) {\n    }\n\n    private String getFirstNonEmptyLine(final BufferedReader br) throws IOException {\n    }\n}\n\n```\n\n```java\npackage util;\n\npublic class Coordinate {\n\n    public final int row;\n\n    public final int col;\n\n    public Coordinate(int row, int col) {\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n    }\n\n    public boolean equals(Coordinate other) {\n    }\n\n    @Override\n    public int hashCode() {\n    }\n\n    public Coordinate add(Coordinate other) {\n    }\n}\n\n```\n\n```java\npackage game.map;\n\npublic class Map {\n\n    private final int rows;\n\n    private final int cols;\n\n    public final Cell[][] cells;\n\n    private TerminationCell sourceCell;\n\n    private TerminationCell sinkCell;\n\n    private final Set<Coordinate> filledTiles = new HashSet<>();\n\n    private int prevFilledTiles = 0;\n\n    private Integer prevFilledDistance;\n\n    public Map(int rows, int cols) {\n    }\n\n    public Map(int rows, int cols, Cell[][] cells) {\n    }\n\n    static Map fromString(int rows, int cols, String cellsRep) {\n    }\n\n    public boolean tryPlacePipe(final Coordinate coord, final Pipe pipe) {\n    }\n\n    boolean tryPlacePipe(int row, int col, Pipe p) {\n    }\n\n    public void display() {\n    }\n\n    public void undo(final Coordinate coord) {\n    }\n\n    public void fillBeginTile() {\n    }\n\n    public void fillTiles(int distance) {\n    }\n\n    public boolean checkPath() {\n    }\n\n    public boolean hasLost() {\n    }\n}\n\n```\n\n```java\npackage game;\n\npublic class DelayBar {\n\n    private final int initialValue;\n\n    private int currentValue;\n\n    DelayBar(int initialValue) {\n    }\n\n    void countdown() {\n    }\n\n    int distance() {\n    }\n\n    void display() {\n    }\n}\n\n```\n\n```java\npackage game;\n\npublic class CellStack {\n\n    private final Stack<FillableCell> cellStack = new Stack<>();\n\n    private int count = 0;\n\n    void push(final FillableCell cell) {\n    }\n\n    FillableCell pop() {\n    }\n\n    int getUndoCount() {\n    }\n\n    void display() {\n    }\n}\n\n```\n\n```java\npackage game;\n\npublic class PipeQueue {\n\n    private static final int MAX_GEN_LENGTH = 5;\n\n    private final LinkedList<Pipe> pipeQueue;\n\n    PipeQueue() {\n    }\n\n    PipeQueue(List<Pipe> pipes) {\n    }\n\n    Pipe peek() {\n    }\n\n    void consume() {\n    }\n\n    void undo(final Pipe pipe) {\n    }\n\n    void display() {\n    }\n\n    private static Pipe generateNewPipe() {\n    }\n}\n\n```\n"}
{"task_id": "PA19/PipeQueue.java", "target": "game/PipeQueue.java", "code": "```java\npackage game;\n\nimport game.pipes.Pipe;\nimport game.pipes.Pipe.Shape;\n\nimport java.io.*;\nimport java.util.*;\n\n/**\n * Class encapsulating the pipe queue.\n */\npublic class PipeQueue {\n\n    /**\n     * Maximum number of pipes to display in the queue.\n     */\n    private static final int MAX_GEN_LENGTH = 5;\n\n    private final LinkedList<Pipe> pipeQueue;\n\n    /**\n     * Creates a pipe queue with {@link PipeQueue#MAX_GEN_LENGTH} number of pipes.\n     *\n     * <p>\n     * This method should also populate the queue until it has {@link PipeQueue#MAX_GEN_LENGTH} number of pipes in it.\n     * </p>\n     */\n    PipeQueue() {\n        // TODO\n    }\n\n    /**\n     * Creates a pipe queue with pipes already filled in the queue. Ultimately, it should contain\n     * {@link PipeQueue#MAX_GEN_LENGTH} number of pipes.\n     *\n     * <p>\n     * This method should also populate the queue until it has {@link PipeQueue#MAX_GEN_LENGTH} number of pipes in it.\n     * </p>\n     *\n     * @param pipes List of pipes to display before generated pipes.\n     */\n    PipeQueue(List<Pipe> pipes) {\n        // TODO\n    }\n\n    /**\n     * Peeks the next pipe.\n     *\n     * @return The next pipe in the queue.\n     * @throws IllegalStateException if there are no pipes in the queue.\n     */\n    Pipe peek() {\n        // TODO\n    }\n\n    /**\n     * Consumes the next pipe.\n     *\n     * This method removes the pipe from the queue, and generate new ones if the queue has less elements than\n     * {@link PipeQueue#MAX_GEN_LENGTH}.\n     */\n    void consume() {\n        // TODO\n    }\n\n    /**\n     * Undoes a step by inserting {@code pipe} into the front of the queue.\n     *\n     * @param pipe Pipe to insert to front of queue.\n     */\n    void undo(final Pipe pipe) {\n        // TODO\n    }\n\n    /**\n     * Displays the current queue.\n     */\n    void display() {\n        System.out.print(\"Next Pipes:  \");\n        for (Pipe p : pipeQueue) {\n            System.out.print(p.toSingleChar() + \"    \");\n        }\n        System.out.println();\n    }\n\n    /**\n     * Generates a new pipe.\n     *\n     * <p>\n     * Hint: Use {@link java.util.Random#nextInt(int)} to generate random numbers.\n     * </p>\n     *\n     * @return A new pipe.\n     */\n    private static Pipe generateNewPipe() {\n        // TODO\n    }\n}\n\n```\n", "code_context": "```java\npackage game.pipes;\n\npublic class Pipe implements MapElement {\n\n    private final Shape shape;\n\n    private boolean filled = false;\n\n    public Pipe(Shape shape) {\n    }\n\n    public void setFilled() {\n    }\n\n    public boolean getFilled() {\n    }\n\n    public Direction[] getConnections() {\n    }\n\n    @Override\n    public char toSingleChar() {\n    }\n\n    public static Pipe fromString(String rep) {\n    }\n\n    public enum Shape {\n\n        HORIZONTAL(PipePatterns.Filled.HORIZONTAL, PipePatterns.Unfilled.HORIZONTAL),\n        VERTICAL(PipePatterns.Filled.VERTICAL, PipePatterns.Unfilled.VERTICAL),\n        TOP_LEFT(PipePatterns.Filled.TOP_LEFT, PipePatterns.Unfilled.TOP_LEFT),\n        TOP_RIGHT(PipePatterns.Filled.TOP_RIGHT, PipePatterns.Unfilled.TOP_RIGHT),\n        BOTTOM_LEFT(PipePatterns.Filled.BOTTOM_LEFT, PipePatterns.Unfilled.BOTTOM_LEFT),\n        BOTTOM_RIGHT(PipePatterns.Filled.BOTTOM_RIGHT, PipePatterns.Unfilled.BOTTOM_RIGHT),\n        CROSS(PipePatterns.Filled.CROSS, PipePatterns.Unfilled.CROSS);\n\n        final char filledChar;\n\n        final char unfilledChar;\n\n        Shape(char filled, char unfilled) {\n        }\n\n        char getCharByState(boolean isFilled) {\n        }\n    }\n}\n\n```\n"}
